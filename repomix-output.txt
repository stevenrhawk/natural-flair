This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-05T16:46:55.548Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
.github/
  workflows/
    hassfest.yaml
    release.yml
    validate.yaml
  stale.yml
custom_components/
  flair/
    translations/
      en.json
      hr.json
      sk.json
    __init__.py
    binary_sensor.py
    button.py
    climate.py
    config_flow.py
    const.py
    coordinator.py
    cover.py
    manifest.json
    number.py
    select.py
    sensor.py
    strings.json
    switch.py
    util.py
CODEOWNERS
hacs.json
LICENSE
README.md

================================================================
Files
================================================================

================
File: .github/workflows/hassfest.yaml
================
name: Validate with hassfest

on:
  push:
  pull_request:
  schedule:
    - cron: "0 0 * * *"

jobs:
  validate:
    runs-on: "ubuntu-latest"
    steps:
      - uses: "actions/checkout@v3"
      - uses: home-assistant/actions/hassfest@master

================
File: .github/workflows/release.yml
================
name: "Release"

on:
  release:
    types: [published, edited]

permissions: {}

jobs:
  release:
    name: "Release"
    runs-on: "ubuntu-latest"
    permissions:
      contents: write
    steps:
      - name: "Checkout the repository"
        uses: "actions/checkout@v3.5.3"

      - name: "Adjust version number"
        shell: "bash"
        run: |
          yq -i -o json '.version="${{ github.event.release.tag_name }}"' \
            "${{ github.workspace }}/custom_components/flair/manifest.json"

      - name: "ZIP the integration directory"
        shell: "bash"
        run: |
          cd "${{ github.workspace }}/custom_components/flair"
          zip naturalflair.zip -r ./

      - name: "Upload the ZIP file to the release"
        uses: softprops/action-gh-release@v0.1.15
        with:
          files: ${{ github.workspace }}/custom_components/flair/naturalflair.zip

================
File: .github/workflows/validate.yaml
================
name: Validate

on:
  push:
  pull_request:
  schedule:
    - cron: "0 0 * * *"

jobs:
  validate:
    runs-on: "ubuntu-latest"
    steps:
      - uses: "actions/checkout@v3"
      - name: HACS validation
        uses: "hacs/action@main"
        with:
          category: "integration"

================
File: .github/stale.yml
================
# Number of days of inactivity before an issue becomes stale
daysUntilStale: 5
# Number of days of inactivity before a stale issue is closed
daysUntilClose: 2
# Issues with these labels will never be considered stale
exemptLabels:
  - pinned
  - enhancement
# Label to use when marking an issue as stale
staleLabel: stale
# Comment to post when marking an issue as stale. Set to `false` to disable
markComment: >
  This issue has been automatically marked as stale because it has not had
  recent activity. It will be closed if no further activity occurs. Thank you
  for your contributions.
# Comment to post when closing a stale issue. Set to `false` to disable
closeComment: false

================
File: custom_components/flair/translations/en.json
================
{
    "config": {
        "abort": {
            "already_configured": "Flair account is already configured",
            "reauth_successful": "Re-authentication was successful"
        },
        "error": {
            "cannot_connect": "Failed to connect",
            "invalid_auth": "Invalid authentication. Are your credentials correct?",
            "no_structures": "No structures discovered",
            "no_user": "No user found on account"
        },
        "step": {
            "user": {
                "data": {
                    "client_id": "OAuth 2.0 client_id",
                    "client_secret": "OAuth 2.0 client_secret"
                },
                "title": "Fill in your Flair OAuth 2.0 credentials"
            },
            "reauth_confirm": {
                "data": {
                    "client_id": "OAuth 2.0 client_id",
                    "client_secret": "OAuth 2.0 client_secret"
                },
                "title": "Reauthenticate with your Flair OAuth 2.0 credentials"
            }
        }
    }
}

================
File: custom_components/flair/translations/hr.json
================
{
    "config": {
        "abort": {
            "already_configured": "Flair račun je već konfiguriran",
            "reauth_successful": "Ponovna provjera autentičnosti je bila uspješna"
        },
        "error": {
            "cannot_connect": "Povezivanje nije uspjelo",
            "invalid_auth": "Nevažeća provjera autentičnosti. Jesu li vaše vjerodajnice točne?",
            "no_structures": "Nema pronađenih struktura",
            "no_user": "Nijedan korisnik nije pronađen na računu"
        },
        "step": {
            "user": {
                "data": {
                    "client_id": "OAuth 2.0 client_id",
                    "client_secret": "OAuth 2.0 client_secret"
                },
                "title": "Ispunite svoje Flair OAuth 2.0 vjerodajnice"
            },
            "reauth_confirm": {
                "data": {
                    "client_id": "OAuth 2.0 client_id",
                    "client_secret": "OAuth 2.0 client_secret"
                },
                "title": "Ponovo se autentificirajte sa svojim Flair OAuth 2.0 vjerodajnicama"
            }
        }
    }
}

================
File: custom_components/flair/translations/sk.json
================
{
    "config": {
        "abort": {
            "already_configured": "Flair účet je už nakonfigurovaný",
            "reauth_successful": "Opätovné overenie bolo úspešné"
        },
        "error": {
            "cannot_connect": "Nepodarilo sa pripojiť",
            "invalid_auth": "Neplatné overenie. Sú vaše poverenia správne?",
            "no_structures": "Nenašli sa žiadne štruktúry",
            "no_user": "Na účte sa nenašiel žiadny používateľ"
        },
        "step": {
            "user": {
                "data": {
                    "client_id": "OAuth 2.0 client_id",
                    "client_secret": "OAuth 2.0 client_secret"
                },
                "title": "Vyplňte svoje poverenia Flair OAuth 2.0"
            },
            "reauth_confirm": {
                "data": {
                    "client_id": "OAuth 2.0 client_id",
                    "client_secret": "OAuth 2.0 client_secret"
                },
                "title": "Znova sa overte pomocou poverení Flair OAuth 2.0"
            }
        }
    }
}

================
File: custom_components/flair/__init__.py
================
"""Flair Component."""
from __future__ import annotations

from homeassistant.config_entries import ConfigEntry
from homeassistant.const import CONF_CLIENT_ID
from homeassistant.core import HomeAssistant
from homeassistant.helpers import device_registry as dr

from .const import DOMAIN, LOGGER, PLATFORMS
from .coordinator import FlairDataUpdateCoordinator
from .util import NoStructuresError, NoUserError, async_validate_api


async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    """Set up Flair from a config entry."""

    coordinator = FlairDataUpdateCoordinator(hass, entry)
    await coordinator.async_config_entry_first_refresh()
    hass.data.setdefault(DOMAIN, {})[entry.entry_id] = coordinator

    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)

    return True


async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    """Unload Flair config entry."""

    if unload_ok := await hass.config_entries.async_unload_platforms(entry, PLATFORMS):
        del hass.data[DOMAIN][entry.entry_id]
        if not hass.data[DOMAIN]:
            del hass.data[DOMAIN]
    return unload_ok


async def async_migrate_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    """Migrate old entry."""

    if entry.version == 1:
        LOGGER.warning("The current version of home-assistant-flair requires OAuth2 credentials. Please reauthorize using OAuth2 credentials (NOT OAuth1).")
        entry.async_start_reauth(hass)

    if entry.version == 2:
        LOGGER.info("Migrating Flair config entry to version 2.1")
        # Prior to release 0.1.3, unique_id was not set when a user migrated
        # from OAuth1.0 to 2.0 via reauthentication. In this case, if not present,
        # unique_id needs to be set and entry version set to the latest version.

        hass.config_entries.async_update_entry(
            entry,
            unique_id=entry.data[CONF_CLIENT_ID],
            version=2.1
        )

    return True

async def async_remove_config_entry_device(
    hass: HomeAssistant, config_entry: ConfigEntry, device_entry: dr.DeviceEntry
) -> bool:
    """Remove a config entry from a device."""
    return True

================
File: custom_components/flair/binary_sensor.py
================
"""Binary Sensor platform for Flair integration."""
from __future__ import annotations

from typing import Any

from datetime import datetime, timedelta
from flairaio.model import Bridge, Puck, Vent

from homeassistant.components.binary_sensor import (
    BinarySensorDeviceClass,
    BinarySensorEntity,
)
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity import EntityCategory
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .const import DOMAIN, LOGGER, TYPE_TO_MODEL
from .coordinator import FlairDataUpdateCoordinator


async def async_setup_entry(
    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
) -> None:
    """Set Up Flair Binary Sensor Entities."""

    coordinator: FlairDataUpdateCoordinator = hass.data[DOMAIN][entry.entry_id]

    binary_sensors = []

    for structure_id, structure_data in coordinator.data.structures.items():
            # Pucks
            if structure_data.pucks:
                for puck_id, puck_data in structure_data.pucks.items():
                    binary_sensors.append(Connectivity(coordinator, structure_id, puck_id, 'pucks'))
            # Vents
            if structure_data.vents:
                for vent_id, vent_data in structure_data.vents.items():
                    binary_sensors.append(Connectivity(coordinator, structure_id, vent_id, 'vents'))
            # Bridges
            if structure_data.bridges:
                for bridge_id, bridge_data in structure_data.bridges.items():
                    binary_sensors.append(Connectivity(coordinator, structure_id, bridge_id, 'bridges'))

    async_add_entities(binary_sensors)


class Connectivity(CoordinatorEntity, BinarySensorEntity):
    """Representation of Bridge, Puck, and Vent connection status."""

    def __init__(self, coordinator, structure_id, device_id, device_type):
        super().__init__(coordinator)
        self.device_id = device_id
        self.device_type = device_type
        self.structure_id = structure_id
        self.last_logged = None
        self.next_log = None

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_data(self) -> Bridge | Puck | Vent:
        """Handle coordinator device data."""

        if self.device_type == 'pucks':
            return self.structure_data.pucks[self.device_id]
        elif self.device_type == 'vents':
            return self.structure_data.vents[self.device_id]
        else:
            return self.structure_data.bridges[self.device_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.device_data.id)},
            "name": self.device_data.attributes['name'],
            "manufacturer": "Flair",
            "model": TYPE_TO_MODEL[self.device_type],
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.device_data.id) + '_connectivity'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Connection status"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to diagnostic."""

        return EntityCategory.DIAGNOSTIC

    @property
    def device_class(self) -> BinarySensorDeviceClass:
        """Return entity device class."""

        return BinarySensorDeviceClass.CONNECTIVITY

    @property
    def is_on(self) -> bool:
        """Return True if device is online (connected to a gateway)."""

        if not self.device_data.attributes['inactive']:
            return True
        else:
            current_dt = datetime.now()
            if not self.last_logged:
                LOGGER.warning(
                    f'Flair {TYPE_TO_MODEL[self.device_type]}: {self.device_data.attributes["name"]} is reported to be offline.'
                )
                self.last_logged = current_dt
                self.next_log = current_dt + timedelta(seconds=300)
            else:
                # If 5 minutes has elapsed since the last log, log the device being offline.
                if (self.next_log - current_dt).total_seconds() <= 0:
                    LOGGER.warning(
                        f'Flair {TYPE_TO_MODEL[self.device_type]}: {self.device_data.attributes["name"]} is reported to be offline.'
                    )
                    self.last_logged = current_dt
                    self.next_log = current_dt + timedelta(seconds=300)
            return False

================
File: custom_components/flair/button.py
================
"""Button platform for Flair integration."""
from __future__ import annotations

from typing import Any

from flairaio.model import Room, Structure

from homeassistant.components.button import ButtonEntity
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .const import DOMAIN
from .coordinator import FlairDataUpdateCoordinator


async def async_setup_entry(
    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
) -> None:
    """Set Up Flair Button Entities."""

    coordinator: FlairDataUpdateCoordinator = hass.data[DOMAIN][entry.entry_id]

    buttons = []

    for structure_id, structure_data in coordinator.data.structures.items():
            # Structures
            buttons.extend((
                HomeAwayClearHold(coordinator, structure_id),
                HomeAwayRevert(coordinator, structure_id),
            ))

            # Rooms
            if structure_data.rooms:
                for room_id, room_data in structure_data.rooms.items():
                    buttons.extend((
                        RoomClearHold(coordinator, structure_id, room_id),
                    ))

            # HVAC Units with only button controls
            if structure_data.hvac_units:
                for hvac_id, hvac_data in structure_data.hvac_units.items():
                    constraints = structure_data.hvac_units[hvac_id].attributes['constraints']
                    if isinstance(constraints, list):
                        for constraint in constraints:
                            buttons.append(HVACUnitControlButton(coordinator, structure_id, hvac_id, constraint))

    async_add_entities(buttons)


class HomeAwayClearHold(CoordinatorEntity, ButtonEntity):
    """Representation of clearing home/away hold."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.structure_data.id) + '_home_away_clear_hold'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Clear home/away hold"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""

        system_mode = self.structure_data.attributes['mode']
        if system_mode == 'manual':
            return False
        else:
            return True

    @property
    def available(self) -> bool:
        """Marks entity as unavailable if system mode is set to Manual."""

        system_mode = self.structure_data.attributes['mode']
        if system_mode == 'manual':
            return False
        else:
            return True

    async def async_press(self) -> None:
        """Handle the button press."""

        attributes = {
            "hold-until": None
        }

        await self.coordinator.client.update('structures', self.structure_data.id, attributes, relationships={})
        self.structure_data.attributes['hold-until'] = None
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()


class HomeAwayRevert(CoordinatorEntity, ButtonEntity):
    """Representation of clearing home/away hold and reverting to previous state."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.structure_data.id) + '_home_away_reverse'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Reverse home/away hold"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""

        system_mode = self.structure_data.attributes['mode']
        if system_mode == 'manual':
            return False
        else:
            return True

    @property
    def available(self) -> bool:
        """Marks entity as unavailable if system mode is set to Manual."""

        system_mode = self.structure_data.attributes['mode']
        if system_mode == 'manual':
            return False
        else:
            return True

    async def async_press(self) -> None:
        """Handle the button press."""

        home_attributes, hold_attributes = self.set_attributes()
        await self.coordinator.client.update('structures', self.structure_data.id, home_attributes, relationships={})
        await self.coordinator.client.update('structures', self.structure_data.id, hold_attributes, relationships={})
        self.structure_data.attributes['home'] = home_attributes['home']
        self.structure_data.attributes['hold-until'] = None
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    def set_attributes(self) -> tuple[dict[str, bool], dict[str, None]]:
        """Creates attributes dictionary."""

        is_home = self.structure_data.attributes['home']
        if is_home:
            setting = False
        else:
            setting = True

        home_attributes = {
            "home": setting
        }

        hold_attributes = {
            "hold-until": None
        }

        return home_attributes, hold_attributes


class RoomClearHold(CoordinatorEntity, ButtonEntity):
    """Representation of clearing room temperature hold."""

    def __init__(self, coordinator, structure_id, room_id):
        super().__init__(coordinator)
        self.room_id = room_id
        self.structure_id = structure_id

    @property
    def room_data(self) -> Room:
        """Handle coordinator room data."""

        return self.coordinator.data.structures[self.structure_id].rooms[self.room_id]

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.room_data.id)},
            "name": self.room_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Room",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.room_data.id) + '_clear_hold'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Clear hold"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""

        system_mode = self.structure_data.attributes['mode']
        if system_mode == 'manual':
            return False
        else:
            return True

    @property
    def available(self) -> bool:
        """Marks entity as unavailable if system mode is set to Manual."""

        system_mode = self.structure_data.attributes['mode']
        if system_mode == 'manual':
            return False
        else:
            return True

    async def async_press(self) -> None:
        """Handle the button press."""

        attributes = {
            "hold-until": None,
            "hold-until-schedule-event": False
        }

        await self.coordinator.client.update('rooms', self.room_data.id, attributes, relationships={})
        self.room_data.attributes['hold-until'] = None
        self.room_data.attributes['hold-until-schedule-event'] = False
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()


class HVACUnitControlButton(CoordinatorEntity, ButtonEntity):
    """Representation of button available for HVAC unit."""

    def __init__(self, coordinator, structure_id, hvac_id, constraint):
        super().__init__(coordinator)
        self.hvac_id = hvac_id
        self.structure_id = structure_id
        self.constraint = constraint

    @property
    def hvac_data(self) -> HVACUnit:
        """Handle coordinator HVAC unit data."""

        return self.coordinator.data.structures[self.structure_id].hvac_units[self.hvac_id]

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""

        puck_id = self.hvac_data.relationships['puck']['data']['id']
        return self.coordinator.data.structures[self.structure_id].pucks[puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.hvac_data.id)},
            "name": self.hvac_data.attributes['name'],
            "manufacturer": self.hvac_data.attributes['make-name'],
            "model": "HVAC Unit",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.hvac_data.id) + f'_{self.constraint}'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return self.constraint.capitalize()

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def icon(self) -> str:
        """Set hvac icon."""

        return 'mdi:hvac'

    @property
    def available(self) -> bool:
        """Return true if associated puck is available."""

        if not self.puck_data.attributes['inactive']:
            return True
        else:
            return False

    async def async_press(self) -> None:
        """Handle the button press."""

        attributes = {
            "button-presses": [self.constraint]
        }

        await self.coordinator.client.update('hvac-units', self.hvac_data.id, attributes=attributes, relationships={})
        await self.coordinator.async_request_refresh()

================
File: custom_components/flair/climate.py
================
"""Climate platform for Flair integration."""
from __future__ import annotations

from typing import Any

from flairaio.exceptions import FlairError
from flairaio.model import HVACUnit, Puck, Room, Structure

from homeassistant.components.climate import (
    ClimateEntity,
    ClimateEntityFeature,
    HVACAction,
    HVACMode,
)
from homeassistant.components.climate.const import (
    ATTR_HVAC_MODE,
    FAN_AUTO,
    FAN_HIGH,
    FAN_LOW,
    FAN_MEDIUM,
    SWING_OFF,
    SWING_ON,
)
from homeassistant.const import (
    ATTR_TEMPERATURE,
    UnitOfTemperature,
)
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.exceptions import HomeAssistantError
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity
from homeassistant.util.unit_system import METRIC_SYSTEM

from .const import (
    DOMAIN,
    HVAC_AVAILABLE_FAN_SPEEDS,
    HVAC_AVAILABLE_MODES_MAP,
    HVAC_CURRENT_ACTION,
    HVAC_CURRENT_FAN_SPEED,
    HVAC_CURRENT_MODE_MAP,
    HVAC_SWING_STATE,
    LOGGER,
    ROOM_HVAC_MAP,
)
from .coordinator import FlairDataUpdateCoordinator

# Mappings
ROOM_HVAC_MAP_TO_FLAIR = {v: k for (k, v) in ROOM_HVAC_MAP.items()}
HASS_HVAC_MODE_TO_FLAIR = {v: k for (k, v) in HVAC_CURRENT_MODE_MAP.items()}
HASS_HVAC_FAN_SPEED_TO_FLAIR = {v: k for (k, v) in HVAC_CURRENT_FAN_SPEED.items()}
HASS_HVAC_SWING_TO_FLAIR = {v: k for (k, v) in HVAC_SWING_STATE.items()}


async def async_setup_entry(
    hass: HomeAssistant,
    entry: ConfigEntry,
    async_add_entities: AddEntitiesCallback
) -> None:
    """Set up Flair Climate Entities."""

    coordinator: FlairDataUpdateCoordinator = hass.data[DOMAIN][entry.entry_id]

    climates = []

    for structure_id, structure_data in coordinator.data.structures.items():
        # Structure-level climate entity
        climates.append(StructureClimate(coordinator, structure_id))

        # Room-level climate entities
        if structure_data.rooms:
            for room_id in structure_data.rooms:
                climates.append(RoomTemp(coordinator, structure_id, room_id))

        # IR mini-split / advanced HVAC units
        if structure_data.hvac_units:
            for hvac_id, hvac_data in structure_data.hvac_units.items():
                constraints = hvac_data.attributes["constraints"]
                if isinstance(constraints, dict):  # means it's a more advanced IR device
                    codesets = hvac_data.attributes["codesets"][0]
                    if (
                        "temperature-scale" not in constraints
                        and "temperature-scale" not in codesets
                    ):
                        unit_name = hvac_data.attributes["name"]
                        LOGGER.error(
                            f"Flair HVAC Unit {unit_name} does not have a temperature scale. "
                            "Contact Flair support to get this fixed."
                        )
                    else:
                        climates.append(HVAC(coordinator, structure_id, hvac_id))

    async_add_entities(climates)


class StructureClimate(CoordinatorEntity, ClimateEntity):
    """Representation of Structure-wide HVAC (like a central thermostat)."""

    _enable_turn_on_off_backwards_compatibility = False

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes["name"],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        return f"{self.structure_data.id}_climate"

    @property
    def name(self) -> str:
        return "Structure"

    @property
    def has_entity_name(self) -> bool:
        return True

    @property
    def temperature_unit(self) -> UnitOfTemperature:
        # Convert celsius/fahrenheit based on HA’s system
        return (
            UnitOfTemperature.CELSIUS
            if self.hass.config.units is METRIC_SYSTEM
            else UnitOfTemperature.FAHRENHEIT
        )

    @property
    def target_temperature(self) -> float:
        """Return the structure set point, converting if necessary."""
        c_value = self.structure_data.attributes["set-point-temperature-c"]
        if self.hass.config.units is METRIC_SYSTEM:
            return c_value
        return round((c_value * 9 / 5) + 32)

    @property
    def hvac_mode(self) -> HVACMode | None:
        """Map structure-heat-cool-mode to an HA HVACMode."""
        flair_mode = self.structure_data.attributes["structure-heat-cool-mode"]
        return ROOM_HVAC_MAP.get(flair_mode, HVACMode.OFF)

    @property
    def hvac_modes(self) -> list[HVACMode]:
        """Off, Heat, Cool, Heat/Cool at the structure level."""
        return [HVACMode.OFF, HVACMode.COOL, HVACMode.HEAT, HVACMode.HEAT_COOL]

    @property
    def supported_features(self) -> int:
        return ClimateEntityFeature.TARGET_TEMPERATURE | ClimateEntityFeature.TURN_OFF

    @property
    def entity_registry_enabled_default(self) -> bool:
        # Disable if structure is in "manual" mode
        return self.structure_data.attributes["mode"] != "manual"

    @property
    def available(self) -> bool:
        # Also show as unavailable if "manual" system mode
        return self.structure_data.attributes["mode"] != "manual"

    async def async_turn_off(self) -> None:
        """Change structure's heat-cool-mode to 'float' which means off."""
        await self._update_structure_mode("float")
        self.structure_data.attributes["structure-heat-cool-mode"] = "float"
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    async def async_set_hvac_mode(self, hvac_mode: HVACMode) -> None:
        """Set structure hvac mode."""
        flair_mode = ROOM_HVAC_MAP_TO_FLAIR.get(hvac_mode, "float")
        await self._update_structure_mode(flair_mode)
        self.structure_data.attributes["structure-heat-cool-mode"] = flair_mode
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    async def async_set_temperature(self, **kwargs) -> None:
        """Change the set-point temperature at the structure."""
        if self.structure_data.attributes["set-point-mode"] == (
            "Home Evenness For Active Rooms Follow Third Party"
        ):
            LOGGER.error(
                f"Target temperature for {self.structure_data.attributes['name']} can only be set "
                "when the set point controller is Flair app"
            )
            return

        new_temp = kwargs.get(ATTR_TEMPERATURE)
        if not new_temp:
            LOGGER.error(f"Missing valid arguments for set_temperature in {kwargs}")
            return

        if self.hass.config.units is not METRIC_SYSTEM:
            # Convert from F to C
            new_temp = round(((new_temp - 32) * 5 / 9), 2)

        await self._update_structure_temp(new_temp)
        self.structure_data.attributes["set-point-temperature-c"] = new_temp
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    async def _update_structure_mode(self, flair_mode: str) -> None:
        """Send update to the structure for its heat-cool-mode."""
        data = {"structure-heat-cool-mode": flair_mode}
        await self.coordinator.client.update("structures", self.structure_data.id, data, relationships={})

    async def _update_structure_temp(self, new_temp_c: float) -> None:
        """Send new set point to structure in celsius."""
        data = {"set-point-temperature-c": new_temp_c}
        await self.coordinator.client.update("structures", self.structure_data.id, data, relationships={})


class RoomTemp(CoordinatorEntity, ClimateEntity):
    """Representation of a single Flair Room as a climate entity."""

    _enable_turn_on_off_backwards_compatibility = False

    def __init__(self, coordinator, structure_id, room_id):
        super().__init__(coordinator)
        self.structure_id = structure_id
        self.room_id = room_id

    @property
    def room_data(self) -> Room:
        return self.coordinator.data.structures[self.structure_id].rooms[self.room_id]

    @property
    def structure_data(self) -> Structure:
        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        return {
            "identifiers": {(DOMAIN, self.room_data.id)},
            "name": self.room_data.attributes["name"],
            "manufacturer": "Flair",
            "model": "Room",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        return f"{self.room_data.id}_room"

    @property
    def name(self) -> str:
        return "Room"

    @property
    def has_entity_name(self) -> bool:
        return True

    @property
    def icon(self) -> str:
        return "mdi:door-open"

    @property
    def temperature_unit(self) -> UnitOfTemperature:
        """Flair room temps are always in celsius natively."""
        return UnitOfTemperature.CELSIUS

    @property
    def hvac_mode(self) -> HVACMode | None:
        """If the room is inactive, reflect OFF. Otherwise, map structure-heat-cool-mode."""
        if not self.room_data.attributes.get("active", True):
            return HVACMode.OFF

        flair_mode = self.structure_data.attributes["structure-heat-cool-mode"]
        return ROOM_HVAC_MAP.get(flair_mode, HVACMode.OFF)

    @property
    def hvac_modes(self) -> list[HVACMode]:
        """Allow OFF, COOL, HEAT, HEAT_COOL for rooms."""
        return [HVACMode.OFF, HVACMode.COOL, HVACMode.HEAT, HVACMode.HEAT_COOL]

    @property
    def current_temperature(self) -> float:
        return self.room_data.attributes.get("current-temperature-c") or 0.0

    @property
    def target_temperature(self) -> float:
        return self.room_data.attributes.get("set-point-c") or 0.0

    @property
    def current_humidity(self) -> int:
        return self.room_data.attributes.get("current-humidity") or 0

    @property
    def supported_features(self) -> int:
        return ClimateEntityFeature.TARGET_TEMPERATURE | ClimateEntityFeature.TURN_OFF

    @property
    def entity_registry_enabled_default(self) -> bool:
        # If the system is manual, we don't enable by default
        return self.structure_data.attributes["mode"] != "manual"

    @property
    def available(self) -> bool:
        # If the system is manual, we show as unavailable
        if self.structure_data.attributes["mode"] == "manual":
            return False
        # Also, if the room has no current temperature reading, we consider it not available
        return self.room_data.attributes.get("current-temperature-c") is not None

    async def async_turn_off(self) -> None:
        """
        Instead of changing structure-heat-cool-mode for just this room,
        we can mark this room as inactive in Flair's API.
        """
        data = {"active": False}
        await self.coordinator.client.update("rooms", self.room_data.id, data, relationships={})
        self.room_data.attributes["active"] = False
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    async def async_set_hvac_mode(self, hvac_mode: HVACMode) -> None:
        """
        If user sets OFF => mark the room inactive.
        Otherwise => mark the room active, then update structure mode.
        """
        if hvac_mode == HVACMode.OFF:
            # Mark room inactive
            data = {"active": False}
            await self.coordinator.client.update("rooms", self.room_data.id, data, relationships={})
            self.room_data.attributes["active"] = False
            self.async_write_ha_state()
            await self.coordinator.async_request_refresh()
            return

        # If not OFF, ensure room is active
        if not self.room_data.attributes.get("active", True):
            data = {"active": True}
            await self.coordinator.client.update("rooms", self.room_data.id, data, relationships={})
            self.room_data.attributes["active"] = True

        # Now set the structure’s heat-cool-mode
        flair_mode = ROOM_HVAC_MAP_TO_FLAIR.get(hvac_mode, "float")
        struct_data = {"structure-heat-cool-mode": flair_mode}
        await self.coordinator.client.update("structures", self.structure_data.id, struct_data, relationships={})
        self.structure_data.attributes["structure-heat-cool-mode"] = flair_mode
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    async def async_set_temperature(self, **kwargs) -> None:
        """Set new target temperature for this room."""
        new_temp = kwargs.get(ATTR_TEMPERATURE)
        if new_temp is None:
            LOGGER.error(f"Missing valid arguments for set_temperature in {kwargs}")
            return

        data = {"set-point-c": new_temp, "active": True}
        await self.coordinator.client.update("rooms", self.room_data.id, data, relationships={})
        self.room_data.attributes["set-point-c"] = new_temp
        self.room_data.attributes["active"] = True
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()


class HVAC(CoordinatorEntity, ClimateEntity):
    """
    Representation of a single IR mini-split HVAC unit, which uses
    Flair’s IR commands. If you want “OFF => inactive room” logic,
    you can implement that similarly, but typically these IR units
    are controlled individually and *may* or may not reflect the
    underlying room's active status.
    """

    _enable_turn_on_off_backwards_compatibility = False

    def __init__(self, coordinator, structure_id, hvac_id):
        super().__init__(coordinator)
        self.structure_id = structure_id
        self.hvac_id = hvac_id

    @property
    def hvac_data(self) -> HVACUnit:
        return self.coordinator.data.structures[self.structure_id].hvac_units[self.hvac_id]

    @property
    def structure_data(self) -> Structure:
        return self.coordinator.data.structures[self.structure_id]

    @property
    def puck_data(self) -> Puck:
        # For diagnostic availability, etc.
        puck_id = self.hvac_data.relationships["puck"]["data"]["id"]
        return self.structure_data.pucks[puck_id]

    @property
    def room_data(self) -> Room:
        room_id = self.hvac_data.relationships["room"]["data"]["id"]
        return self.structure_data.rooms[room_id]

    @property
    def device_info(self) -> dict[str, Any]:
        return {
            "identifiers": {(DOMAIN, self.hvac_data.id)},
            "name": self.hvac_data.attributes["name"],
            "manufacturer": self.hvac_data.attributes["make-name"],
            "model": "HVAC Unit",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        return f"{self.hvac_data.id}_hvac_unit"

    @property
    def name(self) -> str:
        return "HVAC unit"

    @property
    def has_entity_name(self) -> bool:
        return True

    @property
    def icon(self) -> str:
        return "mdi:hvac"

    @property
    def temperature_unit(self) -> UnitOfTemperature:
        # The unit is read from constraints
        constraints = self.hvac_data.attributes["constraints"]
        if "temperature-scale" in constraints:
            scale = constraints["temperature-scale"]
        else:
            scale = self.hvac_data.attributes["codesets"][0]["temperature-scale"]

        return (
            UnitOfTemperature.FAHRENHEIT
            if scale == "F"
            else UnitOfTemperature.CELSIUS
        )

    @property
    def is_on(self) -> bool:
        """If Flair says 'power': 'On', then it's on."""
        return self.hvac_data.attributes["power"] == "On"

    # ...Remaining logic for modes, fan speeds, swing, etc. remains largely the same...

    # If you want “OFF => inactive room,” replicate the same pattern from RoomTemp
    # (But typically these IR units are “manually” toggled, so it’s up to you.)

    # ...

================
File: custom_components/flair/config_flow.py
================
"""Config Flow for Flair integration."""
from __future__ import annotations

from collections.abc import Mapping
from typing import Any

from flairaio.exceptions import FlairAuthError
import voluptuous as vol

from homeassistant import config_entries
from homeassistant.const import CONF_CLIENT_ID, CONF_CLIENT_SECRET
from homeassistant.data_entry_flow import FlowResult
import homeassistant.helpers.config_validation as cv

from .const import DEFAULT_NAME, DOMAIN
from .util import NoStructuresError, NoUserError, async_validate_api


DATA_SCHEMA = vol.Schema(
    {
        vol.Required(CONF_CLIENT_ID): cv.string,
        vol.Required(CONF_CLIENT_SECRET): cv.string,
    }
)


class FlairConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):
    """Handle a config flow for Flair integration."""

    VERSION = 2.1

    entry: config_entries.ConfigEntry | None

    async def async_step_reauth(self, entry_data: Mapping[str, Any]) -> FlowResult:
        """Handle re-authentication with Flair."""

        self.entry = self.hass.config_entries.async_get_entry(self.context["entry_id"])
        return await self.async_step_reauth_confirm()

    async def async_step_reauth_confirm(
            self, user_input: dict[str, Any] | None = None
    ) -> FlowResult:
        """Confirm re-authentication with Flair."""

        errors: dict[str, str] = {}

        if user_input:
            client_id = user_input[CONF_CLIENT_ID]
            client_secret = user_input[CONF_CLIENT_SECRET]
            try:
                await async_validate_api(self.hass, client_id, client_secret)
            except FlairAuthError:
                errors["base"] = "invalid_auth"
            except ConnectionError:
                errors["base"] = "cannot_connect"
            except NoStructuresError:
                errors["base"] = "no_structures"
            except NoUserError:
                errors["base"] = "no_user"
            else:
                assert self.entry is not None

                if self.entry.version == 1:
                    self.entry.version = 2.1
                    self.entry.unique_id = client_id
                    self.hass.config_entries._async_schedule_save()

                self.hass.config_entries.async_update_entry(
                    self.entry,
                    data={
                        **self.entry.data,
                        CONF_CLIENT_ID: client_id,
                        CONF_CLIENT_SECRET: client_secret,
                    },
                )

                await self.hass.config_entries.async_reload(self.entry.entry_id)
                return self.async_abort(reason="reauth_successful")

        return self.async_show_form(
            step_id="reauth_confirm",
            data_schema=DATA_SCHEMA,
            errors=errors,
        )

    async def async_step_user(
            self, user_input: dict[str, Any] | None = None
    ) -> FlowResult:
        """Handle the initial step."""

        errors: dict[str, str] = {}

        if user_input:
            client_id = user_input[CONF_CLIENT_ID]
            client_secret = user_input[CONF_CLIENT_SECRET]
            try:
                await async_validate_api(self.hass, client_id, client_secret)
            except FlairAuthError:
                errors["base"] = "invalid_auth"
            except ConnectionError:
                errors["base"] = "cannot_connect"
            except NoStructuresError:
                errors["base"] = "no_structures"
            except NoUserError:
                errors["base"] = "no_user"
            else:
                await self.async_set_unique_id(client_id)
                self._abort_if_unique_id_configured()

                return self.async_create_entry(
                    title=DEFAULT_NAME,
                    data={CONF_CLIENT_ID: client_id, CONF_CLIENT_SECRET: client_secret},
                )

        return self.async_show_form(
            step_id="user",
            data_schema=DATA_SCHEMA,
            errors=errors,
        )

================
File: custom_components/flair/const.py
================
"""Constants for Flair"""

import asyncio
import logging

from aiohttp.client_exceptions import ClientConnectionError
from flairaio.exceptions import FlairAuthError, FlairError

from homeassistant.components.climate import HVACAction, HVACMode
from homeassistant.components.climate.const import (
    FAN_AUTO,
    FAN_HIGH,
    FAN_LOW,
    FAN_MEDIUM,
    SWING_OFF,
    SWING_ON,
)
from homeassistant.const import Platform


LOGGER = logging.getLogger(__package__)


DEFAULT_SCAN_INTERVAL = 30
DOMAIN = "flair"
PLATFORMS = [
    Platform.BINARY_SENSOR,
    Platform.BUTTON,
    Platform.CLIMATE,
    Platform.COVER,
    Platform.NUMBER,
    Platform.SELECT,
    Platform.SENSOR,
    Platform.SWITCH,
]

DEFAULT_NAME = "Flair"
TIMEOUT = 20

FLAIR_ERRORS = (
    asyncio.TimeoutError,
    ClientConnectionError,
    FlairAuthError,
    FlairError,
)

# Dictionaries and lists.

AWAY_MODES = [
    "Smart Away",
    "Off Only",
]

DEFAULT_HOLD_DURATION = {
    "Until": "Until next scheduled event",
    "3h": "3 Hours",
    "8h": "8 Hours",
    "24h": "24 Hours",
    "Forever": "Forever",
}

HOME_AWAY_MODE = [
    "Home",
    "Away",
]

HOME_AWAY_SET_BY = {
    "Manual": "Manual",
    "Third Party Home Away": "Thermostat",
    "Flair Autohome Autoaway": "Flair App Geolocation",
}

HVAC_AVAILABLE_FAN_SPEEDS = {
    "FAN AUTO": FAN_AUTO,
    "FAN HI": FAN_HIGH,
    "FAN MID": FAN_MEDIUM,
    "FAN LOW": FAN_LOW,
}

HVAC_AVAILABLE_MODES_MAP = {
    "DRY": HVACMode.DRY,
    "HEAT": HVACMode.HEAT,
    "COOL": HVACMode.COOL,
    "FAN": HVACMode.FAN_ONLY,
    "AUTO": HVACMode.HEAT_COOL,
}

HVAC_CURRENT_ACTION = {
    HVACMode.OFF: HVACAction.OFF,
    HVACMode.HEAT: HVACAction.HEATING,
    HVACMode.COOL: HVACAction.COOLING,
    HVACMode.DRY: HVACAction.DRYING,
    HVACMode.FAN_ONLY: HVACAction.FAN,
}

HVAC_CURRENT_FAN_SPEED = {
    "Auto": FAN_AUTO,
    "High": FAN_HIGH,
    "Medium": FAN_MEDIUM,
    "Low": FAN_LOW,
}

HVAC_CURRENT_MODE_MAP = {
    "Off": HVACMode.OFF,
    "Dry": HVACMode.DRY,
    "Heat": HVACMode.HEAT,
    "Cool": HVACMode.COOL,
    "Fan": HVACMode.FAN_ONLY,
    "Auto": HVACMode.HEAT_COOL,
}

HVAC_SWING_STATE = {
    "On": SWING_ON,
    "Off": SWING_OFF,
}

PUCK_BACKGROUND = [
    "Black",
    "White",
]

ROOM_HVAC_MAP = {
    "float": HVACMode.OFF,
    "heat": HVACMode.HEAT,
    "cool": HVACMode.COOL,
    "auto": HVACMode.HEAT_COOL,
}

ROOM_MODES = [
    "Active",
    "Inactive",
]

SET_POINT_CONTROLLER = {
    "Home Evenness For Active Rooms Follow Third Party": "Thermostat",
    "Home Evenness For Active Rooms Flair Setpoint": "Flair App",
}

SYSTEM_MODES = [
    "Auto",
    "Manual",
]

TEMPERATURE_SCALES = {
    "F": "Fahrenheit",
    "C": "Celsius",
    "K": "Kelvin",
}

TYPE_TO_MODEL = {
    "users": "User",
    "structures": "Structure",
    "rooms": "Room",
    "pucks": "Puck",
    "vents": "Vent",
    "bridges": "Bridge",
    "thermostats": "Thermostat",
    "hvac-units": "HVAC Unit",
    "zones": "Zone",
    "schedules": "Schedule"
}

================
File: custom_components/flair/coordinator.py
================
"""DataUpdateCoordinator for the Flair integration."""
from __future__ import annotations

from datetime import timedelta
import json

from flairaio import FlairClient
from flairaio.exceptions import FlairAuthError, FlairError
from flairaio.model import FlairData


from homeassistant.config_entries import ConfigEntry
from homeassistant.const import CONF_CLIENT_ID, CONF_CLIENT_SECRET
from homeassistant.core import HomeAssistant
from homeassistant.exceptions import ConfigEntryAuthFailed
from homeassistant.helpers.aiohttp_client import async_get_clientsession
from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed

from .const import DEFAULT_SCAN_INTERVAL, DOMAIN, LOGGER, TIMEOUT


class FlairDataUpdateCoordinator(DataUpdateCoordinator):
    """Flair Data Update Coordinator."""

    data: FlairData

    def __init__(self, hass: HomeAssistant, entry: ConfigEntry) -> None:
        """Initialize the Flair coordinator."""

        self.client = FlairClient(
            entry.data[CONF_CLIENT_ID],
            entry.data[CONF_CLIENT_SECRET],
            session=async_get_clientsession(hass),
            timeout=TIMEOUT,
        )
        super().__init__(
            hass,
            LOGGER,
            name=DOMAIN,
            update_interval=timedelta(seconds=DEFAULT_SCAN_INTERVAL),
        )

    async def _async_update_data(self) -> FlairData:
        """Fetch data from Flair."""

        try:
            data = await self.client.get_flair_data()
            nl = '\n'
            LOGGER.debug(f'Found the following Flair structures/devices: {nl}{json.dumps(data, default=vars, indent=4)}')
        except FlairAuthError as error:
            raise ConfigEntryAuthFailed(error) from error
        except FlairError as error:
            raise UpdateFailed(error) from error
        if not data.structures:
            raise UpdateFailed("No Structures found")
        return data

================
File: custom_components/flair/cover.py
================
"""Cover platform for Flair integration."""
from __future__ import annotations

from typing import Any

from flairaio.model import Room, Structure, Vent

from homeassistant.components.cover import (
    ATTR_TILT_POSITION,
    CoverDeviceClass,
    CoverEntity,
    CoverEntityFeature,
)
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .const import DOMAIN, LOGGER
from .coordinator import FlairDataUpdateCoordinator


async def async_setup_entry(
    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
) -> None:
    """Set Up Flair Cover Entities."""

    coordinator: FlairDataUpdateCoordinator = hass.data[DOMAIN][entry.entry_id]

    covers = []

    for structure_id, structure_data in coordinator.data.structures.items():
            # Vents
            if structure_data.vents:
                for vent_id, vent_data in structure_data.vents.items():
                    covers.extend((
                        FlairVent(coordinator, structure_id, vent_id),
                    ))

    async_add_entities(covers)


class FlairVent(CoordinatorEntity, CoverEntity):
    """Representation of Vent device."""

    def __init__(self, coordinator, structure_id, vent_id):
        super().__init__(coordinator)
        self.vent_id = vent_id
        self.structure_id = structure_id

    @property
    def vent_data(self) -> Vent:
        """Handle coordinator vent data."""

        return self.coordinator.data.structures[self.structure_id].vents[self.vent_id]

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def room_data(self) -> Room:
        """Handle coordinator room data."""

        room_id = self.vent_data.relationships['room']['data']['id']
        return self.coordinator.data.structures[self.structure_id].rooms[room_id]

    @property
    def manual_struct_room(self) -> bool:
        """Return true if structure or room is in manual mode."""

        if (self.structure_data.attributes['mode'] == 'manual') or \
           (self.room_data.attributes['current-temperature-c'] is None):
            return True
        else:
            return False

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.vent_data.id)},
            "name": self.vent_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Vent",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.vent_data.id) + '_vent'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Vent"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def device_class(self) -> CoverDeviceClass:
        """Return entity device class."""

        return CoverDeviceClass.DAMPER

    @property
    def icon(self) -> str:
        """Set vent icon."""

        return 'mdi:air-filter'

    @property
    def is_closed(self) -> bool:
        """Return true if vent percent open is zero."""

        if self.vent_data.attributes['percent-open'] == 0:
            return True
        else:
            return False

    @property
    def current_cover_tilt_position(self) -> int:
        """Return the current percent open."""

        return self.vent_data.attributes['percent-open']

    @property
    def supported_features(self) -> int:
        """Vent supported features."""

        return CoverEntityFeature.OPEN_TILT | CoverEntityFeature.CLOSE_TILT | CoverEntityFeature.SET_TILT_POSITION

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.vent_data.attributes['inactive']:
            return True
        else:
            return False

    async def async_open_cover_tilt(self, **kwargs) -> None:
        """Open the vent."""

        attributes = self.set_attributes(100)
        await self.coordinator.client.update('vents', self.vent_data.id, attributes=attributes, relationships={})
        self.vent_data.attributes['percent-open'] = 100
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

        if not self.manual_struct_room:
            LOGGER.warning(f'''Flair structure or room not in manual mode.
                            Position changes to your Flair vent {self.vent_data.attributes["name"]}
                            will eventually be reversed by Flair.
                            '''
                          )

    async def async_close_cover_tilt(self, **kwargs) -> None:
        """Close the vent."""

        attributes = self.set_attributes(0)
        await self.coordinator.client.update('vents', self.vent_data.id, attributes=attributes, relationships={})
        self.vent_data.attributes['percent-open'] = 0
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

        if not self.manual_struct_room:
            LOGGER.warning(f'''Flair structure or room not in manual mode.
                            Position changes to your Flair vent {self.vent_data.attributes["name"]}
                            will eventually be reversed by Flair.
                            '''
                          )

    async def async_set_cover_tilt_position(self, **kwargs) -> None:
        """Set vent percentage open."""

        tilt_position = kwargs.get(ATTR_TILT_POSITION)
        if tilt_position == 0:
            await self.async_close_cover_tilt()
        elif tilt_position == 100:
            await self.async_open_cover_tilt()
        else:
            attributes = self.set_attributes(50)
            await self.coordinator.client.update('vents', self.vent_data.id, attributes=attributes, relationships={})
            self.vent_data.attributes['percent-open'] = 50
            self.async_write_ha_state()
            await self.coordinator.async_request_refresh()

            if not self.manual_struct_room:
                LOGGER.warning(f'''Flair structure or room not in manual mode.
                                Position changes to your Flair vent {self.vent_data.attributes["name"]}
                                will eventually be reversed by Flair.
                                '''
                              )

    @staticmethod
    def set_attributes(percent: int) -> dict[str, Any]:
        """Creates attributes dict that is needed
        by the flairaio update method.
        """

        attributes = {
            "percent-open": percent,
        }
        return attributes

================
File: custom_components/flair/manifest.json
================
{
  "domain": "naturalflair",
  "name": "Natural Flair",
  "codeowners": [
    "@stevenrhawk"
  ],
  "config_flow": true,
  "dependencies": [],
  "documentation": "https://github.com/stevenrhawk/natural-flair/blob/main/README.md",
  "integration_type": "hub",
  "iot_class": "cloud_polling",
  "issue_tracker": "https://github.com/RobertD502/home-assistant-flair/issues",
  "loggers": [
    "flairaio"
  ],  
  "requirements": [
    "flairaio==0.2.0"
  ],
  "version": "0.2.2"
}

================
File: custom_components/flair/number.py
================
"""Number platform for Flair integration."""
from __future__ import annotations

from typing import Any

from flairaio.model import Bridge, Puck, Structure

from homeassistant.components.number import (
    NumberDeviceClass,
    NumberEntity,
    NumberMode,
)
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity import EntityCategory
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity
from homeassistant.const import UnitOfTemperature
from homeassistant.util.unit_system import METRIC_SYSTEM

from .const import DOMAIN
from .coordinator import FlairDataUpdateCoordinator


async def async_setup_entry(
    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
) -> None:
    """Set Up Flair Number Entities."""

    coordinator: FlairDataUpdateCoordinator = hass.data[DOMAIN][entry.entry_id]

    numbers = []

    for structure_id, structure_data in coordinator.data.structures.items():
            # Structures
            numbers.extend((
                TempAwayMin(coordinator, structure_id),
                TempAwayMax(coordinator, structure_id),
            ))

            # Pucks
            if structure_data.pucks:
                for puck_id, puck_data in structure_data.pucks.items():
                    numbers.extend((
                        PuckLowerLimit(coordinator, structure_id, puck_id),
                        PuckUpperLimit(coordinator, structure_id, puck_id),
                        TempCalibration(coordinator, structure_id, puck_id),
                    ))

            # Bridge
            if structure_data.bridges:
                for bridge_id, bridge_data in structure_data.bridges.items():
                    numbers.append(BridgeLED(coordinator, structure_id, bridge_id))

    async_add_entities(numbers)


class TempAwayMin(CoordinatorEntity, NumberEntity):
    """Representation of minimum away temperature."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.structure_data.id) + '_temp_away_min'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Away temperature minimum"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to config."""

        return EntityCategory.CONFIG

    @property
    def icon(self) -> str:
        """Set icon."""

        return 'mdi:thermometer'

    @property
    def native_value(self) -> float:
        """Returns current set point. 

        Due to how Home Assistant handles rounding,
        we need to carry it out ourselves based on if
        Home Assistant is set to imperial or metric.
        """

        value = self.structure_data.attributes['temp-away-min-c']

        if self.hass.config.units is METRIC_SYSTEM:
            return value
        else:
            return round(((value * (9/5)) + 32), 0)

    @property
    def native_unit_of_measurement(self) -> UnitOfTemperature:
        """Return celsius or fahrenheit."""

        if self.hass.config.units is METRIC_SYSTEM:
            return UnitOfTemperature.CELSIUS
        else:
            return UnitOfTemperature.FAHRENHEIT

    @property
    def device_class(self) -> NumberDeviceClass:
        """Return temp device class."""

        return NumberDeviceClass.TEMPERATURE

    @property
    def mode(self) -> NumberMode:
        """Return slider mode."""

        return NumberMode.SLIDER

    @property
    def native_min_value(self) -> float:
        """Return minimum allowed set point in celsius."""

        if self.hass.config.units is METRIC_SYSTEM:
            return 10.0
        else:
            return 50.0

    @property
    def native_max_value(self) -> float:
        """Return maximum allowed min away temp in celsius.

        Always has to be 3 degrees celsius less than the
        maximum away temp setting.
        """

        away_max = self.structure_data.attributes['temp-away-max-c'] - 3

        if self.hass.config.units is METRIC_SYSTEM:
            return away_max
        else:
            return round(((away_max * (9/5)) + 32), 0)

    @property
    def native_step(self) -> float:
        """Return temp stepping by 1 celsius or fahrenheit."""

        return 1.0

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""

        system_mode = self.structure_data.attributes['mode']
        if system_mode == 'manual':
            return False
        else:
            return True

    @property
    def available(self) -> bool:
        """Return true only if the set point controller
        is set to Flair App, away mode is set to Smart Away,
        and system mode is set to auto
        """

        set_point_mode = self.structure_data.attributes['set-point-mode']
        structure_away_mode = self.structure_data.attributes['structure-away-mode']
        system_mode = self.structure_data.attributes['mode'] 
        if (set_point_mode == 'Home Evenness For Active Rooms Flair Setpoint' and structure_away_mode == 'Smart Away') and \
                (system_mode == 'auto'):
            return True
        else:
            return False

    async def async_set_native_value(self, value: float) -> None:
        """Update the current value."""

        if self.hass.config.units is METRIC_SYSTEM:
            temp = value
        else:
            temp = round(((value - 32) * (5/9)), 2)

        attributes = self.set_attributes(temp)
        await self.coordinator.client.update('structures', self.structure_data.id, attributes=attributes, relationships={})
        self.structure_data.attributes['temp-away-min-c'] = temp
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(value: float) -> dict[str, float]:
        """Creates attributes dictionary."""

        attributes = {
            "temp-away-min-c": value
        }
        return attributes


class TempAwayMax(CoordinatorEntity, NumberEntity):
    """Representation of max away temperature."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.structure_data.id) + '_temp_away_max'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Away temperature maximum"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to config."""

        return EntityCategory.CONFIG

    @property
    def icon(self) -> str:
        """Set icon."""

        return 'mdi:thermometer'

    @property
    def native_value(self) -> float:
        """Returns current set point. 

        Due to how Home Assistant handles rounding,
        we need to carry it out ourselves based on if
        Home Assistant is set to imperial or metric.
        """

        value = self.structure_data.attributes['temp-away-max-c']

        if self.hass.config.units is METRIC_SYSTEM:
            return value
        else:
            return round(((value * (9/5)) + 32), 0)

    @property
    def native_unit_of_measurement(self) -> UnitOfTemperature:
        """Return celsius or fahrenheit."""

        if self.hass.config.units is METRIC_SYSTEM:
            return UnitOfTemperature.CELSIUS
        else:
            return UnitOfTemperature.FAHRENHEIT

    @property
    def device_class(self) -> NumberDeviceClass:
        """Return temp device class."""

        return NumberDeviceClass.TEMPERATURE

    @property
    def mode(self) -> NumberMode:
        """Return slider mode."""

        return NumberMode.SLIDER

    @property
    def native_min_value(self) -> float:
        """Return minimum allowed max away temp in celsius.

        Always has to be 3 degrees celsius more than
        the min away temp setting.
        """

        away_min = self.structure_data.attributes['temp-away-min-c'] + 3

        if self.hass.config.units is METRIC_SYSTEM:
            return away_min
        else:
            return round(((away_min * (9/5)) + 32), 0)

    @property
    def native_max_value(self) -> float:
        """Return maximum allowed max away temp in celsius or fahrenheit."""

        if self.hass.config.units is METRIC_SYSTEM:
            return 32.2
        else:
            return 90.0

    @property
    def native_step(self) -> float:
        """Return temp stepping by 1 celsius or fahrenheit."""

        return 1.0

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""

        system_mode = self.structure_data.attributes['mode']
        if system_mode == 'manual':
            return False
        else:
            return True

    @property
    def available(self) -> bool:
        """Return true only if the set point controller
        is set to Flair App, away mode is set to Smart Away,
        and system mode is set to auto
        """

        set_point_mode = self.structure_data.attributes['set-point-mode']
        structure_away_mode = self.structure_data.attributes['structure-away-mode']
        system_mode = self.structure_data.attributes['mode'] 
        if (set_point_mode == 'Home Evenness For Active Rooms Flair Setpoint' and structure_away_mode == 'Smart Away') and \
                (system_mode == 'auto'):
            return True
        else:
            return False

    async def async_set_native_value(self, value: float) -> None:
        """Update the current value."""

        if self.hass.config.units is METRIC_SYSTEM:
            temp = value
        else:
            temp = round(((value - 32) * (5/9)), 2)
        attributes = self.set_attributes(temp)
        await self.coordinator.client.update('structures', self.structure_data.id, attributes=attributes, relationships={})
        self.structure_data.attributes['temp-away-max-c'] = temp
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(value: float) -> dict[str, float]:
        """Creates attributes dictionary."""

        attributes = {
            "temp-away-max-c": value
        }
        return attributes


class PuckLowerLimit(CoordinatorEntity, NumberEntity):
    """Representation of puck set point lower limit."""

    def __init__(self, coordinator, structure_id, puck_id):
        super().__init__(coordinator)
        self.puck_id = puck_id
        self.structure_id = structure_id

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""

        return self.coordinator.data.structures[self.structure_id].pucks[self.puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.puck_data.id)},
            "name": self.puck_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Puck",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.puck_data.id) + '_lower_limit'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Set point lower limit"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to config."""

        return EntityCategory.CONFIG

    @property
    def icon(self) -> str:
        """Set icon."""

        return 'mdi:thermometer'

    @property
    def native_value(self) -> float:
        """Returns current lower limit. 

        Due to how Home Assistant handles rounding,
        we need to carry out rounding on our own depending
        on if HA is in metric or imperial.
        """

        value = self.puck_data.attributes['setpoint-bound-low']

        if self.hass.config.units is METRIC_SYSTEM:
            return value
        else:
            return round(((value * (9/5)) + 32), 0)

    @property
    def native_unit_of_measurement(self) -> UnitOfTemperature:
        """Return celsius or fahrenheit."""

        if self.hass.config.units is METRIC_SYSTEM:
            return UnitOfTemperature.CELSIUS
        else:
            return UnitOfTemperature.FAHRENHEIT

    @property
    def device_class(self) -> NumberDeviceClass:
        """Return temp device class."""

        return NumberDeviceClass.TEMPERATURE

    @property
    def mode(self) -> NumberMode:
        """Return slider mode."""

        return NumberMode.SLIDER

    @property
    def native_min_value(self) -> float:
        """Return minimum allowed lower limit."""

        if self.hass.config.units is METRIC_SYSTEM:
            return 10.0
        else:
            return 50.0

    @property
    def native_max_value(self) -> float:
        """Return maximum allowed lower limit.

        Can only go as high as the current upper limit.
        """

        upper_limit = self.puck_data.attributes['setpoint-bound-high']

        if self.hass.config.units is METRIC_SYSTEM:
            return upper_limit
        else:
            return round(((upper_limit * (9/5)) + 32), 0)

    @property
    def native_step(self) -> float:
        """Return temp stepping by 0.5 celsius or 1 fahrenheit."""

        if self.hass.config.units is METRIC_SYSTEM:
            return 0.5
        else:
            return 1.0

    @property
    def available(self) -> bool:
        """Return true if puck is active."""

        if not self.puck_data.attributes['inactive']:
            return True
        else:
            return False

    async def async_set_native_value(self, value: float) -> None:
        """Update the current value."""

        if self.hass.config.units is METRIC_SYSTEM:
            temp = value
        else:
            temp = round(((value - 32) * (5/9)), 2)

        attributes = self.set_attributes(temp)
        await self.coordinator.client.update('pucks', self.puck_data.id, attributes=attributes, relationships={})
        self.puck_data.attributes['setpoint-bound-low'] = temp
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(value: float) -> dict[str, float]:
        """Creates attributes dictionary."""

        attributes = {
            "setpoint-bound-low": value
        }
        return attributes


class PuckUpperLimit(CoordinatorEntity, NumberEntity):
    """Representation of puck set point upper limit."""

    def __init__(self, coordinator, structure_id, puck_id):
        super().__init__(coordinator)
        self.puck_id = puck_id
        self.structure_id = structure_id

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""

        return self.coordinator.data.structures[self.structure_id].pucks[self.puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.puck_data.id)},
            "name": self.puck_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Puck",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.puck_data.id) + '_upper_limit'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Set point upper limit"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to config."""

        return EntityCategory.CONFIG

    @property
    def icon(self) -> str:
        """Set icon."""

        return 'mdi:thermometer'

    @property
    def native_value(self) -> float:
        """Returns current upper limit. 

        Due to how Home Assistant handles rounding,
        we need to carry out rounding on our own depending
        on if HA is in metric or imperial.
        """

        value = self.puck_data.attributes['setpoint-bound-high']

        if self.hass.config.units is METRIC_SYSTEM:
            return value
        else:
            return round(((value * (9/5)) + 32), 0)

    @property
    def native_unit_of_measurement(self) -> UnitOfTemperature:
        """Return celsius or fahrenheit."""

        if self.hass.config.units is METRIC_SYSTEM:
            return UnitOfTemperature.CELSIUS
        else:
            return UnitOfTemperature.FAHRENHEIT

    @property
    def device_class(self) -> NumberDeviceClass:
        """Return temp device class."""

        return NumberDeviceClass.TEMPERATURE

    @property
    def mode(self) -> NumberMode:
        """Return slider mode."""

        return NumberMode.SLIDER

    @property
    def native_min_value(self) -> float:
        """Return minimum allowed upper limit.

        Can only be as low as the current lower limit.
        """

        lower_limit = self.puck_data.attributes['setpoint-bound-low']

        if self.hass.config.units is METRIC_SYSTEM:
            return lower_limit
        else:
            return round(((lower_limit * (9/5)) + 32), 0)

    @property
    def native_max_value(self) -> float:
        """Return maximum allowed upper limit."""

        if self.hass.config.units is METRIC_SYSTEM:
            return 32.23
        else:
            return 90.0

    @property
    def native_step(self) -> float:
        """Return temp stepping by 0.5 celsius or 1 fahrenheit."""

        if self.hass.config.units is METRIC_SYSTEM:
            return 0.5
        else:
            return 1.0

    @property
    def available(self) -> bool:
        """Return true if puck is active."""

        if not self.puck_data.attributes['inactive']:
            return True
        else:
            return False

    async def async_set_native_value(self, value: float) -> None:
        """Update the current value."""

        if self.hass.config.units is METRIC_SYSTEM:
            temp = value
        else:
            temp = round(((value - 32) * (5/9)), 2)

        attributes = self.set_attributes(temp)
        await self.coordinator.client.update('pucks', self.puck_data.id, attributes=attributes, relationships={})
        self.puck_data.attributes['setpoint-bound-high'] = temp
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(value: float) -> dict[str, float]:
        """Creates attributes dictionary."""

        attributes = {
            "setpoint-bound-high": value
        }
        return attributes


class TempCalibration(CoordinatorEntity, NumberEntity):
    """Representation of puck temperature calibration."""

    def __init__(self, coordinator, structure_id, puck_id):
        super().__init__(coordinator)
        self.puck_id = puck_id
        self.structure_id = structure_id

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""

        return self.coordinator.data.structures[self.structure_id].pucks[self.puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.puck_data.id)},
            "name": self.puck_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Puck",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.puck_data.id) + '_temp_calibration'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Temperature calibration"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to config."""

        return EntityCategory.CONFIG

    @property
    def icon(self) -> str:
        """Set icon."""

        return 'mdi:thermometer'

    @property
    def native_value(self) -> float:
        """Returns current temp calibration.

        Need to add 5C to the reading to get real temp in celsius.
        If HA is set to imperial, we need to subtract 32F from the
        conversion in order to replicate the Flair app UI.
        """

        temp_c = self.puck_data.attributes['temperature-offset-override-c'] + 5.0

        if self.hass.config.units is METRIC_SYSTEM:
            return temp_c
        else:
            return round((temp_c * (9/5)), 0)

    @property
    def native_unit_of_measurement(self) -> UnitOfTemperature:
        """Return celsius or fahrenheit depending on HA settings."""

        if self.hass.config.units is METRIC_SYSTEM:
            return UnitOfTemperature.CELSIUS
        else:
            return UnitOfTemperature.FAHRENHEIT

    @property
    def device_class(self) -> NumberDeviceClass:
        """Return temp device class."""

        return NumberDeviceClass.TEMPERATURE

    @property
    def mode(self) -> NumberMode:
        """Return slider mode."""

        return NumberMode.SLIDER

    @property
    def native_min_value(self) -> float:
        """Return minimum allowed temp calibration.

        If system is in Fahrenheit, we need the lower to be equal
        to -18F.
        """

        if self.hass.config.units is METRIC_SYSTEM:
            return -10.0
        else:
            return -18.0

    @property
    def native_max_value(self) -> float:
        """Return maximum allowed temp calibration.

        If the system is in Fahrenheit, we need the upper value to
        be equal to 9F.
        """

        if self.hass.config.units is METRIC_SYSTEM:
            return 5.0
        else:
            return 9.0

    @property
    def native_step(self) -> float:
        """Return temp stepping by 0.5C or 1F."""

        if self.hass.config.units is METRIC_SYSTEM:
            return 0.5
        else:
            return 1.0

    @property
    def available(self) -> bool:
        """Return true if puck is active and offset exists."""

        puck_inactive = self.puck_data.attributes['inactive']
        temp_offset = self.puck_data.attributes['temperature-offset-override-c']

        if (puck_inactive == False) and (temp_offset is not None):
            return True
        else:
            return False

    async def async_set_native_value(self, value: float) -> None:
        """Update the current value."""

        if self.hass.config.units is METRIC_SYSTEM:
            # Need to subtract 5 celsius to get value
            # Flair servers expect.
            ha_to_flair = value - 5.0
        else:
            # Need to get 0F baseline and add the Flair server
            # correction of 5C. Then we subtract this value from our
            # HA value in celsius.
            zero_f_to_c = (-32 * (5/9)) + 5
            value_to_c =  ((value - 32) * (5/9))
            ha_to_flair = (value_to_c - zero_f_to_c)

        attributes = self.set_attributes(ha_to_flair)
        await self.coordinator.client.update('pucks', self.puck_data.id, attributes=attributes, relationships={})
        self.puck_data.attributes['temperature-offset-override-c'] = ha_to_flair
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(value: float) -> dict[str, float]:
        """Creates attributes dictionary."""

        attributes = {
            "temperature-offset-override-c": value
        }
        return attributes


class BridgeLED(CoordinatorEntity, NumberEntity):
    """Representation of bridge LED brightness."""

    def __init__(self, coordinator, structure_id, bridge_id):
        super().__init__(coordinator)
        self.bridge_id = bridge_id
        self.structure_id = structure_id

    @property
    def bridge_data(self) -> Bridge:
        """Handle coordinator bridge data."""

        return self.coordinator.data.structures[self.structure_id].bridges[self.bridge_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.bridge_data.id)},
            "name": self.bridge_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Bridge",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.bridge_data.id) + '_led'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "LED brightness"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to config."""

        return EntityCategory.CONFIG

    @property
    def icon(self) -> str:
        """Set icon."""

        return 'mdi:led-on'

    @property
    def native_value(self) -> int:
        """Returns current LED brightness."""

        return self.bridge_data.attributes['led-brightness']

    @property
    def mode(self) -> NumberMode:
        """Return slider mode."""

        return NumberMode.SLIDER

    @property
    def native_min_value(self) -> int:
        """Return minimum allowed brightness."""

        return 20

    @property
    def native_max_value(self) -> int:
        """Return max allowed brightness."""

        return 100

    @property
    def native_step(self) -> int:
        """Return whole number stepping."""

        return 1

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.bridge_data.attributes['inactive']:
            return True
        else:
            return False

    async def async_set_native_value(self, value: float) -> None:
        """Update the current value."""

        attributes = self.set_attributes(value)
        await self.coordinator.client.update('bridges', self.bridge_data.id, attributes=attributes, relationships={})
        self.bridge_data.attributes['led-brightness'] = value
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(value: int) -> dict[str, int]:
        """Creates attributes dictionary."""

        attributes = {
            "led-brightness": value
        }
        return attributes

================
File: custom_components/flair/select.py
================
"""Select platform for Flair integration."""
from __future__ import annotations

from typing import Any

from flairaio.model import Puck, Structure

from homeassistant.components.select import SelectEntity
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity import EntityCategory
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .const import (
    AWAY_MODES,
    DEFAULT_HOLD_DURATION,
    DOMAIN,
    HOME_AWAY_MODE,
    HOME_AWAY_SET_BY,
    PUCK_BACKGROUND,
    SET_POINT_CONTROLLER,
    SYSTEM_MODES,
    TEMPERATURE_SCALES,
)
from .coordinator import FlairDataUpdateCoordinator


DEFAULT_HOLD_TO_FLAIR = {v: k for (k, v) in DEFAULT_HOLD_DURATION.items()}
HOME_AWAY_SET_BY_TO_FLAIR = {v: k for (k, v) in HOME_AWAY_SET_BY.items()}
SET_POINT_CONTROLLER_TO_FLAIR = {v: k for (k, v) in SET_POINT_CONTROLLER.items()}
TEMP_SCALE_TO_FLAIR = {v: k for (k, v) in TEMPERATURE_SCALES.items()}


async def async_setup_entry(
    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
) -> None:
    """Set Up Flair Select Entities."""

    coordinator: FlairDataUpdateCoordinator = hass.data[DOMAIN][entry.entry_id]
    selects = []

    for structure_id, structure_data in coordinator.data.structures.items():
        # Structures
        selects.extend((
            SystemMode(coordinator, structure_id),
            HomeAwayMode(coordinator, structure_id),
            HomeAwaySetBy(coordinator, structure_id),
            DefaultHoldDuration(coordinator, structure_id),
            SetPointController(coordinator, structure_id),
            Schedule(coordinator, structure_id),
            AwayMode(coordinator, structure_id),
        ))

        # Pucks
        if structure_data.pucks:
            for puck_id, puck_data in structure_data.pucks.items():
                selects.extend((
                    PuckBackground(coordinator, structure_id, puck_id),
                    PuckTempScale(coordinator, structure_id, puck_id),
                ))

    async_add_entities(selects)


class SystemMode(CoordinatorEntity, SelectEntity):
    """Representation of System Mode."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""
        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""
        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""
        return f"{self.structure_data.id}_system_mode"

    @property
    def name(self) -> str:
        """Return name of the entity."""
        return "System mode"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""
        return True

    @property
    def icon(self) -> str:
        """Set icon."""
        return "mdi:home-circle"

    @property
    def current_option(self) -> str:
        """Returns currently active system mode."""
        current_mode = self.structure_data.attributes["mode"]
        return current_mode.capitalize()

    @property
    def options(self) -> list[str]:
        """Return list of all the available system modes."""
        return SYSTEM_MODES

    async def async_select_option(self, option: str) -> None:
        """Change the selected option."""
        lowercase_option = option[0].lower() + option[1:]
        attributes = self.set_attributes(str(lowercase_option))
        await self.coordinator.client.update(
            "structures",
            self.structure_data.id,
            attributes=attributes,
            relationships={},
        )
        self.structure_data.attributes["mode"] = lowercase_option
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(mode: str) -> dict[str, str]:
        """Creates attributes dictionary."""
        return {"mode": mode}


class HomeAwayMode(CoordinatorEntity, SelectEntity):
    """Representation of Home/Away Mode."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""
        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""
        return {
            "identifiers": {(DOMAIN, self.structure_id)},
            "name": self.structure_data.attributes["name"],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""
        return f"{self.structure_data.id}_home_away_mode"

    @property
    def name(self) -> str:
        """Return name of the entity."""
        return "Home/Away"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""
        return True

    @property
    def icon(self) -> str:
        """Set icon."""
        return "mdi:location-enter" if self.structure_data.attributes["home"] else "mdi:location-exit"

    @property
    def current_option(self) -> str | None:
        """Returns currently active home/away mode."""
        currently_home = self.structure_data.attributes["home"]
        return "Home" if currently_home else "Away"

    @property
    def options(self) -> list[str]:
        """Return list of all the available home/away modes."""
        return HOME_AWAY_MODE

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""
        system_mode = self.structure_data.attributes["mode"]
        return system_mode != "manual"

    @property
    def available(self) -> bool:
        """Marks entity as unavailable if system mode is set to Manual."""
        return self.structure_data.attributes["mode"] != "manual"

    async def async_select_option(self, option: str) -> None:
        """Change the selected option."""
        attributes = self.set_attributes(option)
        await self.coordinator.client.update(
            "structures",
            self.structure_data.id,
            attributes=attributes,
            relationships={},
        )
        self.structure_data.attributes["home"] = attributes["home"]
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(mode: str) -> dict[str, bool]:
        """Creates attributes dictionary."""
        return {"home": (mode == "Home")}


class HomeAwaySetBy(CoordinatorEntity, SelectEntity):
    """Representation of what sets Home/Away Mode."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""
        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""
        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes["name"],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""
        return f"{self.structure_data.id}_home_away_set_by"

    @property
    def name(self) -> str:
        """Return name of the entity."""
        return "Home/Away mode set by"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""
        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to config."""
        return EntityCategory.CONFIG

    @property
    def icon(self) -> str:
        """Set icon."""
        mode = self.structure_data.attributes["home-away-mode"]
        if mode == "Manual":
            return "mdi:account-circle"
        elif mode == "Third Party Home Away":
            return "mdi:thermostat"
        elif mode == "Flair Autohome Autoaway":
            return "mdi:cellphone"
        return "mdi:account-circle"

    @property
    def current_option(self) -> str | None:
        """Returns currently active home/away mode setter."""
        current = self.structure_data.attributes["home-away-mode"]
        return HOME_AWAY_SET_BY.get(current)

    @property
    def options(self) -> list[str]:
        """Return list of all the available home/away setters."""
        if self.structure_data.thermostats:
            return list(HOME_AWAY_SET_BY.values())
        else:
            return ["Manual", "Flair App Geolocation"]

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""
        return self.structure_data.attributes["mode"] != "manual"

    @property
    def available(self) -> bool:
        """Marks entity as unavailable if system mode is set to Manual."""
        return self.structure_data.attributes["mode"] != "manual"

    async def async_select_option(self, option: str) -> None:
        """Change the selected option."""
        ha_to_flair = HOME_AWAY_SET_BY_TO_FLAIR.get(option)
        attributes = self.set_attributes(ha_to_flair)
        await self.coordinator.client.update(
            "structures",
            self.structure_data.id,
            attributes=attributes,
            relationships={},
        )
        self.structure_data.attributes["home-away-mode"] = ha_to_flair
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(setter: str) -> dict[str, str]:
        """Creates attributes dictionary."""
        return {"home-away-mode": setter}


class DefaultHoldDuration(CoordinatorEntity, SelectEntity):
    """Representation of default hold duration setting."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""
        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""
        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes["name"],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""
        return f"{self.structure_data.id}_default_hold_duration"

    @property
    def name(self) -> str:
        """Return name of the entity."""
        return "Default hold duration"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""
        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to config."""
        return EntityCategory.CONFIG

    @property
    def icon(self) -> str:
        """Set icon."""
        return "mdi:timer"

    @property
    def current_option(self) -> str | None:
        """Returns currently active default hold duration."""
        current = self.structure_data.attributes["default-hold-duration"]
        return DEFAULT_HOLD_DURATION.get(current)

    @property
    def options(self) -> list[str]:
        """Return list of all the available default hold durations."""
        return list(DEFAULT_HOLD_DURATION.values())

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""
        return self.structure_data.attributes["mode"] != "manual"

    @property
    def available(self) -> bool:
        """Marks entity as unavailable if system mode is set to Manual."""
        return self.structure_data.attributes["mode"] != "manual"

    async def async_select_option(self, option: str) -> None:
        """Change the selected option."""
        ha_to_flair = DEFAULT_HOLD_TO_FLAIR.get(option)
        attributes = self.set_attributes(ha_to_flair)
        await self.coordinator.client.update(
            "structures",
            self.structure_data.id,
            attributes=attributes,
            relationships={},
        )
        self.structure_data.attributes["default-hold-duration"] = ha_to_flair
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(duration: str) -> dict[str, str]:
        """Creates attributes dictionary."""
        return {"default-hold-duration": duration}


class SetPointController(CoordinatorEntity, SelectEntity):
    """Representation of set point controller setting."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""
        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""
        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes["name"],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""
        return f"{self.structure_data.id}_set_point_controller"

    @property
    def name(self) -> str:
        """Return name of the entity."""
        return "Set point controller"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""
        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to config."""
        return EntityCategory.CONFIG

    @property
    def icon(self) -> str:
        """Set icon."""
        return "mdi:controller"

    @property
    def current_option(self) -> str | None:
        """Returns current set point controller."""
        current = self.structure_data.attributes["set-point-mode"]
        return SET_POINT_CONTROLLER.get(current)

    @property
    def options(self) -> list[str]:
        """Return list of all the available set point controllers."""
        if self.structure_data.thermostats:
            return list(SET_POINT_CONTROLLER.values())
        return ["Flair App"]

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""
        return self.structure_data.attributes["mode"] != "manual"

    @property
    def available(self) -> bool:
        """Marks entity as unavailable if system mode is set to Manual."""
        return self.structure_data.attributes["mode"] != "manual"

    async def async_select_option(self, option: str) -> None:
        """Change the selected option."""
        ha_to_flair = SET_POINT_CONTROLLER_TO_FLAIR.get(option)
        attributes = self.set_attributes(ha_to_flair)
        await self.coordinator.client.update(
            "structures",
            self.structure_data.id,
            attributes=attributes,
            relationships={},
        )
        self.structure_data.attributes["set-point-mode"] = ha_to_flair
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(option: str) -> dict[str, str]:
        """Creates attributes dictionary."""
        return {"set-point-mode": option}


class Schedule(CoordinatorEntity, SelectEntity):
    """Representation of available structure schedules."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""
        return self.coordinator.data.structures[self.structure_id]

    @property
    def schedules(self) -> dict[str, str]:
        """Create dictionary with all available schedules."""
        schedules: dict[str, str] = {"No Schedule": "No Schedule"}
        if self.structure_data.schedules:
            for sid, schedule_obj in self.structure_data.schedules.items():
                schedules[schedule_obj.id] = schedule_obj.attributes["name"]
        return schedules

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""
        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes["name"],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""
        return f"{self.structure_data.id}_schedule"

    @property
    def name(self) -> str:
        """Return name of the entity."""
        return "Active schedule"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""
        return True

    @property
    def icon(self) -> str:
        """Set icon."""
        return "mdi:calendar"

    @property
    def current_option(self) -> str:
        """Returns current active schedule."""
        active_schedule = self.structure_data.attributes["active-schedule-id"]
        if active_schedule is None:
            return "No Schedule"
        return self.schedules.get(active_schedule, "No Schedule")

    @property
    def options(self) -> list[str]:
        """Return list of all the available schedules."""
        return list(self.schedules.values())

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""
        return self.structure_data.attributes["mode"] != "manual"

    @property
    def available(self) -> bool:
        """Marks entity as unavailable if system mode is set to Manual."""
        return self.structure_data.attributes["mode"] != "manual"

    async def async_select_option(self, option: str) -> None:
        """Change the selected option."""
        schedule_name_to_id = {v: k for k, v in self.schedules.items()}
        ha_to_flair = None if option == "No Schedule" else schedule_name_to_id.get(option)

        attributes = self.set_attributes(ha_to_flair)
        await self.coordinator.client.update(
            "structures",
            self.structure_data.id,
            attributes=attributes,
            relationships={},
        )
        self.structure_data.attributes["active-schedule-id"] = ha_to_flair
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(option: str) -> dict[str, str]:
        """Creates attributes dictionary."""
        return {"active-schedule-id": option}


class AwayMode(CoordinatorEntity, SelectEntity):
    """Representation of structure away mode setting."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""
        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""
        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes["name"],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""
        return f"{self.structure_data.id}_away_mode"

    @property
    def name(self) -> str:
        """Return name of the entity."""
        return "Away Mode"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""
        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to config."""
        return EntityCategory.CONFIG

    @property
    def icon(self) -> str:
        """Set icon."""
        return "mdi:clipboard-list"

    @property
    def current_option(self) -> str:
        """Returns current away mode setting."""
        return self.structure_data.attributes["structure-away-mode"]

    @property
    def options(self) -> list[str]:
        """Return list of all the available away modes."""
        return AWAY_MODES

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""
        return self.structure_data.attributes["mode"] != "manual"

    @property
    def available(self) -> bool:
        """Marks entity as unavailable if system mode is set to Manual."""
        return self.structure_data.attributes["mode"] != "manual"

    async def async_select_option(self, option: str) -> None:
        """Change the selected option."""
        attributes = self.set_attributes(option)
        await self.coordinator.client.update(
            "structures",
            self.structure_data.id,
            attributes=attributes,
            relationships={},
        )
        self.structure_data.attributes["structure-away-mode"] = option
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(option: str) -> dict[str, str]:
        """Creates attributes dictionary."""
        return {"structure-away-mode": option}


class PuckBackground(CoordinatorEntity, SelectEntity):
    """Representation of puck background color."""

    def __init__(self, coordinator, structure_id, puck_id):
        super().__init__(coordinator)
        self.puck_id = puck_id
        self.structure_id = structure_id

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""
        return self.coordinator.data.structures[self.structure_id].pucks[self.puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""
        return {
            "identifiers": {(DOMAIN, self.puck_data.id)},
            "name": self.puck_data.attributes["name"],
            "manufacturer": "Flair",
            "model": "Puck",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""
        return f"{self.puck_data.id}_background_color"

    @property
    def name(self) -> str:
        """Return name of the entity."""
        return "Background color"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""
        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to config."""
        return EntityCategory.CONFIG

    @property
    def icon(self) -> str:
        """Set icon."""
        return "mdi:invert-colors"

    @property
    def current_option(self) -> str:
        """Returns current puck background color."""
        return self.puck_data.attributes["puck-display-color"].capitalize()

    @property
    def options(self) -> list[str]:
        """Return list of all the available puck background colors."""
        return PUCK_BACKGROUND

    @property
    def available(self) -> bool:
        """Return true if puck is active."""
        return not self.puck_data.attributes["inactive"]

    async def async_select_option(self, option: str) -> None:
        """Change the selected option."""
        ha_to_flair = option.lower()
        attributes = self.set_attributes(ha_to_flair)
        await self.coordinator.client.update(
            "pucks",
            self.puck_data.id,
            attributes=attributes,
            relationships={},
        )
        self.puck_data.attributes["puck-display-color"] = ha_to_flair
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(option: str) -> dict[str, str]:
        """Creates attributes dictionary."""
        return {"puck-display-color": option}


class PuckTempScale(CoordinatorEntity, SelectEntity):
    """Representation of puck temp scale selection."""

    def __init__(self, coordinator, structure_id, puck_id):
        super().__init__(coordinator)
        self.puck_id = puck_id
        self.structure_id = structure_id

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""
        return self.coordinator.data.structures[self.structure_id].pucks[self.puck_id]

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""
        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""
        # Some pucks might have 'make-name' in attributes
        manufacturer = self.puck_data.attributes.get("make-name", "Flair")

        return {
            "identifiers": {(DOMAIN, self.puck_data.id)},
            "name": self.puck_data.attributes["name"],
            "manufacturer": manufacturer,
            "model": "Puck",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""
        return f"{self.puck_data.id}_temp_scale"

    @property
    def name(self) -> str:
        """Return name of the entity."""
        return "Temperature scale"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""
        return True

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to config."""
        return EntityCategory.CONFIG

    @property
    def icon(self) -> str:
        """Set icon based on the current scale."""
        temp_scale = self.structure_data.attributes["temperature-scale"]
        if temp_scale == "F":
            return "mdi:temperature-fahrenheit"
        if temp_scale == "C":
            return "mdi:temperature-celsius"
        if temp_scale == "K":
            return "mdi:temperature-kelvin"
        return "mdi:thermometer"

    @property
    def current_option(self) -> str:
        """Returns current puck temp scale."""
        current_scale = self.structure_data.attributes["temperature-scale"]
        return TEMPERATURE_SCALES.get(current_scale, "Fahrenheit")

    @property
    def options(self) -> list[str]:
        """Return list of all the available temperature scales."""
        return list(TEMPERATURE_SCALES.values())

    async def async_select_option(self, option: str) -> None:
        """Change the selected option."""
        ha_to_flair = TEMP_SCALE_TO_FLAIR.get(option)
        attributes = self.set_attributes(ha_to_flair)
        await self.coordinator.client.update(
            "structures",
            self.structure_data.id,
            attributes=attributes,
            relationships={},
        )
        self.puck_data.attributes["temperature-scale"] = ha_to_flair
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    @staticmethod
    def set_attributes(option: str) -> dict[str, str]:
        """Creates attributes dictionary."""
        return {"temperature-scale": option}

================
File: custom_components/flair/sensor.py
================
"""Sensor platform for Flair integration."""
from __future__ import annotations

from datetime import datetime
from typing import Any

from flairaio.model import Bridge, Puck, Room, Structure, Vent

from homeassistant.components.sensor import (
    SensorDeviceClass,
    SensorEntity,
    SensorStateClass,
)
from homeassistant.config_entries import ConfigEntry
from homeassistant.const import(
    LIGHT_LUX,
    PERCENTAGE,
    SIGNAL_STRENGTH_DECIBELS_MILLIWATT,
    UnitOfElectricPotential,
    UnitOfPressure,
    UnitOfTemperature,

)
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity import EntityCategory
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .const import DOMAIN, TYPE_TO_MODEL
from .coordinator import FlairDataUpdateCoordinator


async def async_setup_entry(
    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
) -> None:
    """Set Up Flair Sensor Entities."""

    coordinator: FlairDataUpdateCoordinator = hass.data[DOMAIN][entry.entry_id]

    sensors = []

    for structure_id, structure_data in coordinator.data.structures.items():
            # Structures
            sensors.extend((
                HomeAwayHoldUntil(coordinator, structure_id),
            ))

            # Pucks
            if structure_data.pucks:
                for puck_id, puck_data in structure_data.pucks.items():
                    sensors.extend((
                        PuckTemp(coordinator, structure_id, puck_id),
                        PuckHumidity(coordinator, structure_id, puck_id),
                        PuckLight(coordinator, structure_id, puck_id),
                        PuckVoltage(coordinator, structure_id, puck_id),
                        PuckRSSI(coordinator, structure_id, puck_id),
                        PuckPressure(coordinator, structure_id, puck_id),
                        Gateway(coordinator, structure_id, puck_id, 'pucks')
                    ))
            # Vents
            if structure_data.vents:
                for vent_id, vent_data in structure_data.vents.items():
                    sensors.extend((
                        DuctTemp(coordinator, structure_id, vent_id),
                        DuctPressure(coordinator, structure_id, vent_id),
                        VentVoltage(coordinator, structure_id, vent_id),
                        VentRSSI(coordinator, structure_id, vent_id),
                        VentReportedState(coordinator, structure_id, vent_id),
                        Gateway(coordinator, structure_id, vent_id, 'vents')
                    ))
            # Rooms
            if structure_data.rooms:
                for room_id, room_data in structure_data.rooms.items():
                    sensors.extend((
                        HoldTempUntil(coordinator, structure_id, room_id),
                    ))

            # HVAC Units with only button controls
            if structure_data.hvac_units:
                for hvac_id, hvac_data in structure_data.hvac_units.items():
                    constraints = structure_data.hvac_units[hvac_id].attributes['constraints']
                    if isinstance(constraints, list):
                        sensors.append(LastButtonPressed(coordinator, structure_id, hvac_id))

            # Bridges
            if structure_data.bridges:
                for bridge_id, bridge_data in structure_data.bridges.items():
                    sensors.append(BridgeRSSI(coordinator, structure_id, bridge_id))

    async_add_entities(sensors)


class HomeAwayHoldUntil(CoordinatorEntity, SensorEntity):
    """Representation of default hold duration setting."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.structure_data.id) + '_home_away_hold_until'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Home/Away holding until"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> datetime:
        """Date/time when hold will end.

        When home/away is set manually, returns date/time when hold will end.
        Only applicable if structure default hold duration is anything other
        than 'until next scheduled event'
        """

        if self.structure_data.attributes['hold-until']:
            return datetime.fromisoformat(self.structure_data.attributes['hold-until'])

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.TIMESTAMP

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""

        system_mode = self.structure_data.attributes['mode']
        if system_mode == 'manual':
            return False
        else:
            return True

    @property
    def available(self) -> bool:
        """Determine whether entity is available. 

        Return true if home/away is set manually and structure
        has a default hold duration other than next event.
        """

        if self.structure_data.attributes['hold-until']:
            return True
        else:
            return False


class PuckTemp(CoordinatorEntity, SensorEntity):
    """Representation of Puck Temperature."""

    def __init__(self, coordinator, structure_id, puck_id):
        super().__init__(coordinator)
        self.puck_id = puck_id
        self.structure_id = structure_id

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""

        return self.coordinator.data.structures[self.structure_id].pucks[self.puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.puck_data.id)},
            "name": self.puck_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Puck",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.puck_data.id) + '_temperature'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Temperature"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> float:
        """Return current temperature in Celsius."""

        return self.puck_data.attributes['current-temperature-c']

    @property
    def native_unit_of_measurement(self) -> UnitOfTemperature:
        """Return Celsius as the native unit."""

        return UnitOfTemperature.CELSIUS

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.TEMPERATURE

    @property
    def state_class(self) -> SensorStateClass:
        """Return the type of state class."""

        return SensorStateClass.MEASUREMENT

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.puck_data.attributes['inactive']:
            return True
        else:
            return False


class PuckHumidity(CoordinatorEntity, SensorEntity):
    """Representation of Puck Humidity."""

    def __init__(self, coordinator, structure_id, puck_id):
        super().__init__(coordinator)
        self.puck_id = puck_id
        self.structure_id = structure_id

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""

        return self.coordinator.data.structures[self.structure_id].pucks[self.puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.puck_data.id)},
            "name": self.puck_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Puck",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.puck_data.id) + '_humidity'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Humidity"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> float:
        """Return current humidity."""

        return self.puck_data.attributes['current-humidity']

    @property
    def native_unit_of_measurement(self) -> str:
        """Return percent as the native unit."""

        return PERCENTAGE

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.HUMIDITY

    @property
    def state_class(self) -> SensorStateClass:
        """Return the type of state class."""

        return SensorStateClass.MEASUREMENT

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.puck_data.attributes['inactive']:
            return True
        else:
            return False


class PuckLight(CoordinatorEntity, SensorEntity):
    """Representation of Puck Light."""

    def __init__(self, coordinator, structure_id, puck_id):
        super().__init__(coordinator)
        self.puck_id = puck_id
        self.structure_id = structure_id

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""

        return self.coordinator.data.structures[self.structure_id].pucks[self.puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.puck_data.id)},
            "name": self.puck_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Puck",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.puck_data.id) + '_light'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Light"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> float:
        """Return current lux level. 

        Convert value to Volts then multiply by 200
        for 200 lux per Volt.
        """

        return (self.puck_data.current_reading['light'] / 100) * 200

    @property
    def native_unit_of_measurement(self) -> str:
        """Return lux as the native unit."""

        return LIGHT_LUX

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.ILLUMINANCE

    @property
    def state_class(self) -> SensorStateClass:
        """Return the type of state class."""

        return SensorStateClass.MEASUREMENT

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if (self.puck_data.attributes['inactive'] == False) and \
                (self.puck_data.current_reading['light'] is not None):
            return True
        else:
            return False


class PuckVoltage(CoordinatorEntity, SensorEntity):
    """Representation of Puck Voltage."""

    def __init__(self, coordinator, structure_id, puck_id):
        super().__init__(coordinator)
        self.puck_id = puck_id
        self.structure_id = structure_id

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""

        return self.coordinator.data.structures[self.structure_id].pucks[self.puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.puck_data.id)},
            "name": self.puck_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Puck",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.puck_data.id) + '_voltage'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Voltage"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> float:
        """Return voltage measurement."""

        return self.puck_data.attributes['voltage']

    @property
    def native_unit_of_measurement(self) -> UnitOfElectricPotential:
        """Return volts as the native unit."""

        return UnitOfElectricPotential.VOLT

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.VOLTAGE

    @property
    def state_class(self) -> SensorStateClass:
        """Return the type of state class."""

        return SensorStateClass.MEASUREMENT

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to diagnostic."""

        return EntityCategory.DIAGNOSTIC

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.puck_data.attributes['inactive']:
            return True
        else:
            return False


class PuckRSSI(CoordinatorEntity, SensorEntity):
    """Representation of Puck RSSI."""

    def __init__(self, coordinator, structure_id, puck_id):
        super().__init__(coordinator)
        self.puck_id = puck_id
        self.structure_id = structure_id

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""

        return self.coordinator.data.structures[self.structure_id].pucks[self.puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.puck_data.id)},
            "name": self.puck_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Puck",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.puck_data.id) + '_rssi'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "RSSI"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> float:
        """Return RSSI reading."""

        return self.puck_data.attributes['current-rssi']

    @property
    def native_unit_of_measurement(self) -> str:
        """Return dBm as the native unit."""

        return SIGNAL_STRENGTH_DECIBELS_MILLIWATT

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.SIGNAL_STRENGTH

    @property
    def state_class(self) -> SensorStateClass:
        """Return the type of state class."""

        return SensorStateClass.MEASUREMENT

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to diagnostic."""

        return EntityCategory.DIAGNOSTIC

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.puck_data.attributes['inactive']:
            return True
        else:
            return False


class PuckPressure(CoordinatorEntity, SensorEntity):
    """Representation of Puck pressure reading."""

    def __init__(self, coordinator, structure_id, puck_id):
        super().__init__(coordinator)
        self.puck_id = puck_id
        self.structure_id = structure_id

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""

        return self.coordinator.data.structures[self.structure_id].pucks[self.puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.puck_data.id)},
            "name": self.puck_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Puck",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.puck_data.id) + '_pressure'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Pressure"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> float:
        """Return pressure reading."""

        return round(self.puck_data.current_reading['room-pressure'], 2)

    @property
    def native_unit_of_measurement(self) -> UnitOfPressure:
        """Return kPa as the native unit."""

        return UnitOfPressure.KPA

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.PRESSURE

    @property
    def state_class(self) -> SensorStateClass:
        """Return the type of state class."""

        return SensorStateClass.MEASUREMENT

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.puck_data.attributes['inactive']:
            return True
        else:
            return False


class DuctTemp(CoordinatorEntity, SensorEntity):
    """Representation of Duct Temperature."""

    def __init__(self, coordinator, structure_id, vent_id):
        super().__init__(coordinator)
        self.vent_id = vent_id
        self.structure_id = structure_id

    @property
    def vent_data(self) -> Vent:
        """Handle coordinator vent data."""

        return self.coordinator.data.structures[self.structure_id].vents[self.vent_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.vent_data.id)},
            "name": self.vent_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Vent",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.vent_data.id) + '_duct_temperature'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Duct temperature"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> float:
        """Return current temperature in Celsius."""

        return self.vent_data.current_reading['duct-temperature-c']

    @property
    def native_unit_of_measurement(self) -> UnitOfTemperature:
        """Return Celsius as the native unit."""

        return UnitOfTemperature.CELSIUS

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.TEMPERATURE

    @property
    def state_class(self) -> SensorStateClass:
        """Return the type of state class."""

        return SensorStateClass.MEASUREMENT

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.vent_data.attributes['inactive']:
            return True
        else:
            return False


class DuctPressure(CoordinatorEntity, SensorEntity):
    """Representation of Duct Pressure."""

    def __init__(self, coordinator, structure_id, vent_id):
        super().__init__(coordinator)
        self.vent_id = vent_id
        self.structure_id = structure_id

    @property
    def vent_data(self) -> Vent:
        """Handle coordinator vent data."""

        return self.coordinator.data.structures[self.structure_id].vents[self.vent_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.vent_data.id)},
            "name": self.vent_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Vent",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.vent_data.id) + '_duct_pressure'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Duct pressure"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> float:
        """Return current pressure in kPa."""

        return round(self.vent_data.current_reading['duct-pressure'], 2)

    @property
    def native_unit_of_measurement(self) -> UnitOfPressure:
        """Return kPa as the native unit."""

        return UnitOfPressure.KPA

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.PRESSURE

    @property
    def state_class(self) -> SensorStateClass:
        """Return the type of state class."""

        return SensorStateClass.MEASUREMENT

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.vent_data.attributes['inactive']:
            return True
        else:
            return False


class VentVoltage(CoordinatorEntity, SensorEntity):
    """Representation of Vent Voltage."""

    def __init__(self, coordinator, structure_id, vent_id):
        super().__init__(coordinator)
        self.vent_id = vent_id
        self.structure_id = structure_id


    @property
    def vent_data(self) -> Vent:
        """Handle coordinator vent data."""

        return self.coordinator.data.structures[self.structure_id].vents[self.vent_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.vent_data.id)},
            "name": self.vent_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Vent",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.vent_data.id) + '_voltage'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Voltage"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> float:
        """Return voltage measurement."""

        return self.vent_data.attributes['voltage']

    @property
    def native_unit_of_measurement(self) -> UnitOfElectricPotential:
        """Return volts as the native unit."""

        return UnitOfElectricPotential.VOLT

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.VOLTAGE

    @property
    def state_class(self) -> SensorStateClass:
        """Return the type of state class."""

        return SensorStateClass.MEASUREMENT

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to diagnostic."""

        return EntityCategory.DIAGNOSTIC

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.vent_data.attributes['inactive']:
            return True
        else:
            return False


class VentRSSI(CoordinatorEntity, SensorEntity):
    """Representation of Vent RSSI."""

    def __init__(self, coordinator, structure_id, vent_id):
        super().__init__(coordinator)
        self.vent_id = vent_id
        self.structure_id = structure_id

    @property
    def vent_data(self) -> Vent:
        """Handle coordinator vent data."""

        return self.coordinator.data.structures[self.structure_id].vents[self.vent_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.vent_data.id)},
            "name": self.vent_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Vent",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.vent_data.id) + '_rssi'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "RSSI"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> int:
        """Return RSSI reading."""

        return self.vent_data.attributes['current-rssi']

    @property
    def native_unit_of_measurement(self) -> str:
        """Return dBm as the native unit."""

        return SIGNAL_STRENGTH_DECIBELS_MILLIWATT

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.SIGNAL_STRENGTH

    @property
    def state_class(self) -> SensorStateClass:
        """Return the type of state class."""

        return SensorStateClass.MEASUREMENT

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to diagnostic."""

        return EntityCategory.DIAGNOSTIC

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.vent_data.attributes['inactive']:
            return True
        else:
            return False


class VentReportedState(CoordinatorEntity, SensorEntity):
    """Representation of Vent RSSI."""

    def __init__(self, coordinator, structure_id, vent_id):
        super().__init__(coordinator)
        self.vent_id = vent_id
        self.structure_id = structure_id

    @property
    def vent_data(self) -> Vent:
        """Handle coordinator vent data."""

        return self.coordinator.data.structures[self.structure_id].vents[self.vent_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.vent_data.id)},
            "name": self.vent_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Vent",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.vent_data.id) + '_reported_state'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Reported state"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> int:
        """Return the most recent percent open reading as returned by sensors on vent."""

        return self.vent_data.current_reading['percent-open']

    @property
    def native_unit_of_measurement(self) -> str:
        """Return % as the native unit."""

        return PERCENTAGE

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to diagnostic."""

        return EntityCategory.DIAGNOSTIC

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity on initial registration."""

        return False

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.vent_data.attributes['inactive']:
            return True
        else:
            return False


class HoldTempUntil(CoordinatorEntity, SensorEntity):
    """Representation of Room Temperature Hold End Time."""

    def __init__(self, coordinator, structure_id, room_id):
        super().__init__(coordinator)
        self.room_id = room_id
        self.structure_id = structure_id


    @property
    def room_data(self) -> Room:
        """Handle coordinator room data."""

        return self.coordinator.data.structures[self.structure_id].rooms[self.room_id]

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.room_data.id)},
            "name": self.room_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Room",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.room_data.id) + '_hold_until'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Temperature holding until"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> datetime:
        """Date/time when hold will end.

        When room temperature is set manually,
        returns date/time when hold will end.
        """

        if self.room_data.attributes['hold-until']:
            return datetime.fromisoformat(self.room_data.attributes['hold-until'])

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.TIMESTAMP

    @property
    def entity_registry_enabled_default(self) -> bool:
        """Disable entity if system mode is set to manual on initial registration."""

        system_mode = self.structure_data.attributes['mode']
        if system_mode == 'manual':
            return False
        else:
            return True

    @property
    def available(self) -> bool:
        """Determine if device is available.

        Return true if temp is set manually
        and structure has a default hold duration
        other than next event.
        """

        if self.room_data.attributes['hold-until']:
            return True
        else:
            return False


class LastButtonPressed(CoordinatorEntity, SensorEntity):
    """Representation of last button pressed on HVAC unit with only button control."""

    def __init__(self, coordinator, structure_id, hvac_id):
        super().__init__(coordinator)
        self.hvac_id = hvac_id
        self.structure_id = structure_id

    @property
    def hvac_data(self) -> HVACUnit:
        """Handle coordinator HVAC unit data."""

        return self.coordinator.data.structures[self.structure_id].hvac_units[self.hvac_id]

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""

        puck_id = self.hvac_data.relationships['puck']['data']['id']
        return self.coordinator.data.structures[self.structure_id].pucks[puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.hvac_data.id)},
            "name": self.hvac_data.attributes['name'],
            "manufacturer": self.hvac_data.attributes['make-name'],
            "model": "HVAC Unit",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.hvac_data.id) + '_last_button_pressed'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Last button pressed"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def icon(self) -> str:
        """Set hvac icon."""

        return 'mdi:hvac'

    @property
    def native_value(self) -> float:
        """Return last button pressed."""

        last_pressed = self.hvac_data.attributes['button-presses']
        if last_pressed:
            return last_pressed[0].capitalize()
        else:
            return "No button pressed"

    @property
    def available(self) -> bool:
        """Return true if associated puck is available."""

        if not self.puck_data.attributes['inactive']:
            return True
        else:
            return False


class BridgeRSSI(CoordinatorEntity, SensorEntity):
    """Representation of Bridge RSSI."""

    def __init__(self, coordinator, structure_id, bridge_id):
        super().__init__(coordinator)
        self.bridge_id = bridge_id
        self.structure_id = structure_id

    @property
    def bridge_data(self) -> Bridge:
        """Handle coordinator bridge data."""

        return self.coordinator.data.structures[self.structure_id].bridges[self.bridge_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.bridge_data.id)},
            "name": self.bridge_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Bridge",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.bridge_data.id) + '_rssi'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "RSSI"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> float:
        """Return RSSI reading."""

        return self.bridge_data.attributes['current-rssi']

    @property
    def native_unit_of_measurement(self) -> str:
        """Return dBm as the native unit."""

        return SIGNAL_STRENGTH_DECIBELS_MILLIWATT

    @property
    def device_class(self) -> SensorDeviceClass:
        """Return entity device class."""

        return SensorDeviceClass.SIGNAL_STRENGTH

    @property
    def state_class(self) -> SensorStateClass:
        """Return the type of state class."""

        return SensorStateClass.MEASUREMENT

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to diagnostic."""

        return EntityCategory.DIAGNOSTIC

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.bridge_data.attributes['inactive']:
            return True
        else:
            return False


class Gateway(CoordinatorEntity, SensorEntity):
    """Representation of device's associated gateway."""

    def __init__(self, coordinator, structure_id, device_id, device_type):
        super().__init__(coordinator)
        self.device_id = device_id
        self.device_type = device_type
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_data(self) -> Puck | Vent:
        """Handle coordinator device data."""

        if self.device_type == 'pucks':
            return self.structure_data.pucks[self.device_id]
        else:
            return self.structure_data.vents[self.device_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.device_data.id)},
            "name": self.device_data.attributes['name'],
            "manufacturer": "Flair",
            "model": TYPE_TO_MODEL[self.device_type],
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.device_data.id) + '_gateway'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Associated gateway"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def native_value(self) -> str | None:
        """Return name of associated gateway."""

        return self.get_associated_gateway()

    @property
    def entity_category(self) -> EntityCategory:
        """Set category to diagnostic."""

        return EntityCategory.DIAGNOSTIC

    @property
    def available(self) -> bool:
        """Return true if device is available."""

        if not self.device_data.attributes['inactive']:
            return True
        else:
            return False

    def get_associated_gateway(self) -> str | None:
        """Determines the gateway device is using."""

        connected_gateway_id = self.device_data.attributes['connected-gateway-id']
        connected_gateway_type = self.device_data.attributes['connected-gateway-type']

        if connected_gateway_id:
            if connected_gateway_id == self.device_data.id:
                return 'Self'
            else:
                if connected_gateway_type == 'puck':
                    if gateway := self.structure_data.pucks.get(connected_gateway_id):
                        return gateway.attributes['name']
                    # If the gateway isn't found
                    else:
                        return None
                elif connected_gateway_type == 'bridge':
                    if gateway := self.structure_data.bridges.get(connected_gateway_id):
                        return gateway.attributes['name']
                    # If gateway isn't found
                    else:
                        return None
                else:
                    return None
        else:
            return None

================
File: custom_components/flair/strings.json
================
{
  "config": {
    "step": {
      "user": {
        "title": "Fill in your Flair OAuth 2.0 credentials",
        "data": {
          "client_id": "OAuth 2.0 client_id",
          "client_secret": "OAuth 2.0 client_secret"
        }
      },
      "reauth_confirm": {
        "title": "Reauthenticate with your Flair OAuth 2.0 credentials",
        "data": {
          "client_id": "OAuth 2.0 client_id",
          "client_secret": "OAuth 2.0 client_secret"
        }
      }
    },
    "error": {
      "cannot_connect": "Failed to connect",
      "invalid_auth": "Invalid authentication. Are your credentials correct?",
      "no_structures": "No structures discovered",
      "no_user": "No user found on account"
    },
    "abort": {
      "already_configured": "Flair account is already configured",
      "reauth_successful": "Re-authentication was successful"
    }
  }
}

================
File: custom_components/flair/switch.py
================
"""Switch platform for Flair integration."""
from __future__ import annotations

from typing import Any

from flairaio.model import Puck, Structure

from homeassistant.components.switch import SwitchEntity
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .const import DOMAIN, LOGGER
from .coordinator import FlairDataUpdateCoordinator


async def async_setup_entry(
    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
) -> None:
    """Set Up Flair Switch Entities."""

    coordinator: FlairDataUpdateCoordinator = hass.data[DOMAIN][entry.entry_id]

    switches = []

    for structure_id, structure_data in coordinator.data.structures.items():
            # Structures
            if structure_data.hvac_units:
                switches.extend((
                    LockIR(coordinator, structure_id),
                    NetworkRepair(coordinator, structure_id)
                ))
            
            # Pucks
            if structure_data.pucks:
                for puck_id, puck_data in structure_data.pucks.items():
                    switches.extend((
                        PuckLock(coordinator, structure_id, puck_id),
                    ))

    async_add_entities(switches)


class LockIR(CoordinatorEntity, SwitchEntity):
    """Representation of Structure HVAC IR lock."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.structure_data.id) + '_IR_lock'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Lock IR device modes"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def icon(self) -> str:
        """Set icon."""

        ir_locked = self.structure_data.attributes['hvac-unit-group-lock']

        if ir_locked:
            return 'mdi:lock'
        else:
            return 'mdi:lock-open-variant'

    @property
    def is_on(self) -> bool:
        """Determine if IR is locked."""

        return self.structure_data.attributes['hvac-unit-group-lock']

    async def async_turn_on(self, **kwargs) -> None:
        """Lock the IR devices."""

        attributes = {"hvac-unit-group-lock": True}
        await self.coordinator.client.update('structures', self.structure_data.id, attributes=attributes, relationships={})
        self.structure_data.attributes['hvac-unit-group-lock'] = True
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    async def async_turn_off(self, **kwargs) -> None:
        """Unlock the IR devices."""

        attributes = {"hvac-unit-group-lock": False}
        await self.coordinator.client.update('structures', self.structure_data.id, attributes=attributes, relationships={})
        self.structure_data.attributes['hvac-unit-group-lock'] = False
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()


class PuckLock(CoordinatorEntity, SwitchEntity):
    """Representation of puck lock switch."""

    def __init__(self, coordinator, structure_id, puck_id):
        super().__init__(coordinator)
        self.puck_id = puck_id
        self.structure_id = structure_id

    @property
    def puck_data(self) -> Puck:
        """Handle coordinator puck data."""

        return self.coordinator.data.structures[self.structure_id].pucks[self.puck_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.puck_data.id)},
            "name": self.puck_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Puck",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.puck_data.id) + '_puck_lock'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Lock puck"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def icon(self) -> str:
        """Set icon."""

        puck_locked = self.puck_data.attributes['locked']

        if puck_locked:
            return 'mdi:lock'
        else:
            return 'mdi:lock-open-variant'

    @property
    def is_on(self) -> bool:
        """Return if puck is locked."""

        return self.puck_data.attributes['locked']

    @property
    def available(self) -> bool:
        """Determine if puck is available.

        Return true if puck is active and puck lock setting
        isn't None within the Flair app.
        """

        puck_inactive = self.puck_data.attributes['inactive']
        puck_locked = self.puck_data.attributes['locked']

        if (puck_inactive == False) and (puck_locked is not None):
            return True
        else:
            return False

    async def async_turn_on(self, **kwargs) -> None:
        """Lock the puck."""

        attributes = {"locked": True}
        await self.coordinator.client.update('pucks', self.puck_data.id, attributes=attributes, relationships={})
        self.puck_data.attributes['locked'] = True
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    async def async_turn_off(self, **kwargs) -> None:
        """Unlock the puck."""

        attributes = {"locked": False}
        await self.coordinator.client.update('pucks', self.puck_data.id, attributes=attributes, relationships={})
        self.puck_data.attributes['locked'] = False
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()


class NetworkRepair(CoordinatorEntity, SwitchEntity):
    """Representation of network repair switch."""

    def __init__(self, coordinator, structure_id):
        super().__init__(coordinator)
        self.structure_id = structure_id

    @property
    def structure_data(self) -> Structure:
        """Handle coordinator structure data."""

        return self.coordinator.data.structures[self.structure_id]

    @property
    def device_info(self) -> dict[str, Any]:
        """Return device registry information for this entity."""

        return {
            "identifiers": {(DOMAIN, self.structure_data.id)},
            "name": self.structure_data.attributes['name'],
            "manufacturer": "Flair",
            "model": "Structure",
            "configuration_url": "https://my.flair.co/",
        }

    @property
    def unique_id(self) -> str:
        """Sets unique ID for this entity."""

        return str(self.structure_data.id) + '_network_repair'

    @property
    def name(self) -> str:
        """Return name of the entity."""

        return "Network repair mode"

    @property
    def has_entity_name(self) -> bool:
        """Indicate that entity has name defined."""

        return True

    @property
    def icon(self) -> str:
        """Set icon."""

        return 'mdi:plus-network'

    @property
    def is_on(self) -> bool:
        """Determine if network repair is in progress."""

        return self.structure_data.attributes['setup-mode']

    async def async_turn_on(self, **kwargs) -> None:
        """Enable network repair mode."""

        attributes = {"setup-mode": True}
        await self.coordinator.client.update('structures', self.structure_data.id, attributes=attributes, relationships={})
        self.structure_data.attributes['setup-mode'] = True
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

    async def async_turn_off(self, **kwargs) -> None:
        """Disable network repair mode."""

        attributes = {"setup-mode": False}
        await self.coordinator.client.update('structures', self.structure_data.id, attributes=attributes, relationships={})
        self.structure_data.attributes['setup-mode'] = False
        self.async_write_ha_state()
        await self.coordinator.async_request_refresh()

================
File: custom_components/flair/util.py
================
"""Utilities for Flair Integration"""
from __future__ import annotations

import async_timeout

from flairaio import FlairClient
from flairaio.exceptions import FlairAuthError
from flairaio.model import Structure, User

from homeassistant.core import HomeAssistant
from homeassistant.helpers.aiohttp_client import async_get_clientsession

from .const import LOGGER, FLAIR_ERRORS, TIMEOUT


async def async_validate_api(hass: HomeAssistant, client_id: str, client_secret: str) -> bool:
    """Get data from API."""

    client = FlairClient(
        client_id,
        client_secret,
        session=async_get_clientsession(hass),
        timeout=TIMEOUT,
    )

    try:
        async with async_timeout.timeout(TIMEOUT):
            users_query = await client.get_users()
            structures_query = await client.get_structures()
    except FlairAuthError as err:
        LOGGER.error(f'Could not authenticate on Flair servers: {err}')
        raise FlairAuthError(err)
    except FLAIR_ERRORS as err:
        LOGGER.error(f'Failed to get information from Flair servers: {err}')
        raise ConnectionError from err

    users: dict[str, User] = users_query.users
    structures: dict[str, Structure] = structures_query.structures

    if not users:
        LOGGER.error("Could not retrieve any users from Flair servers")
        raise NoUserError
    if not structures:
        LOGGER.error('Could not retrieve any structures from Flair servers')
        raise NoStructuresError
    return True


class NoUserError(Exception):
    """ No User from Flair API. """


class NoStructuresError(Exception):
    """ No Litter Boxes from PurrSong API. """

================
File: CODEOWNERS
================
*       @RobertD502

================
File: hacs.json
================
{
  "name": "Natural Flair",
  "render_readme": true,
  "country": "US",
  "homeassistant": "2024.2.0b0",
  "zip_release": true,
  "filename": "naturalflair.zip"
}

================
File: LICENSE
================
MIT License

Copyright (c) 2023 RobertD502

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# Flair Home Assistant Integration
[![hacs_badge](https://img.shields.io/badge/HACS-Default-orange.svg)](https://github.com/hacs/integration) ![GitHub manifest version (path)](https://img.shields.io/github/manifest-json/v/RobertD502/home-assistant-flair?filename=custom_components%2Fflair%2Fmanifest.json)

<a href="https://www.buymeacoffee.com/RobertD502" target="_blank"><img src="https://cdn.buymeacoffee.com/buttons/default-orange.png" alt="Buy Me A Coffee" height="100" width="424"></a>
<a href="https://liberapay.com/RobertD502/donate"><img alt="Donate using Liberapay" src="https://liberapay.com/assets/widgets/donate.svg" height="100" width="300"></a>

### A lot of work has been put into creating the backend and this integration. If you enjoy this integration, consider donating by clicking on one of the supported methods above.

***All proceeds go towards helping a local animal rescue.**

___

Custom Home Assistant component for controlling and monitoring Flair structures, bridges, pucks, vents, rooms, and IR HVAC units.

## **Prior To Installation**

**Starting with version `0.1.1` and above**: You will need credentials consisting of **OAuth 2.0** `client_id` and `client_secret`.

If you don't already have these, please [contact Flair Support](https://forms.gle/VohiQjWNv9CAP2ASA) with the email address associated with your registered Flair account.

# Installation

## With HACS

Click on the button below to automatically navigate to the repository within HACS:

[![Open your Home Assistant instance and open a repository inside the Home Assistant Community Store.](https://my.home-assistant.io/badges/hacs_repository.svg)](https://my.home-assistant.io/redirect/hacs_repository/?owner=RobertD502&repository=home-assistant-flair&category=integration)

Alternatively, follow the steps below:

1. Click on the `Explore & Download Repositories` button and search for Flair.
2. On the Flair page, click on the `Download` button.

## Manual
Copy the `flair` directory, from `custom_components` in this repository,
and place it inside your Home Assistant Core installation's `custom_components` directory.

`Note`: If installing manually, in order to be alerted about new releases, you will need to subscribe to releases from this repository. 

## Setup

Click on the button below to add the integration:

[![Open your Home Assistant instance and start setting up a new integration.](https://my.home-assistant.io/badges/config_flow_start.svg)](https://my.home-assistant.io/redirect/config_flow_start/?domain=flair)

Alternatively, follow the steps below:

1. Install this integration.
2. Navigate to the Home Assistant Integrations page (Settings --> Devices & Services)
3. Click the `+ ADD INTEGRATION` button in the lower right-hand corner
4. Search for `Flair`

# Devices

Each Flair mini-split, puck, room, structure, and vent is represented as a device in Home Assistant. Within each device
are several entities described below.


## Structure

Each structure has the following entities:

| Entity                 | Entity Type | Additional Comments                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|------------------------| --- |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Active Schedule`      | `Select` | Schedules are only available if the Flair System Mode is set to "Auto". All schedules created within the Flair app will appear here. To turn off a schedule, select "No Schedule". `Note:` By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                                                                                                                                                              |
| `Clear home/away hold` | `Button` | If you have a hold duration other than "Until next scheduled event", setting the home/away mode manually will result in your setting being held for the defined period of time. Pressing this button will remove the hold. `Note:` Pressing this button will only remove the time period hold, but will keep the home/away mode set to whatever you switched it to. In order to remove the hold and revert back to the original home/away mode, please use the "Reverse home/away hold" button. `Note:` By default, this entity is disabled if Flair system mode is set to manual. `Note:` By default, this entity is disabled if Flair system mode is set to manual. |
| `Home/Away`       | `Select` | Please read Flair's documentation regarding [Home/Away Mode](https://support.flair.co/hc/en-us/articles/360044922952-Home-Away-Mode). `Note:` By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                                                                                                                                                                                                            |
| `Lock IR device modes` | `Switch` | Turning this on will keep heat/cool mode of all IR devices in your Home in sync. It is recommended for Mini-Split systems that share a common outdoor unit, also known as multi-zone systems. `This entity will only be available if you have any IR devices associated with your account.`                                                                                                                                                                                                     |
| `Network repair mode` | `Switch` | Turn this on to temporarily allow Sensor Pucks and Vents to connect to different gatways. `Network repair mode will turn itself off after 30 minutes, if not turned off by the user.`                                                                                                                                                                                                     |
| `Reverse home/away hold` | `Button` | Pressing this button removes the current hold for home/away mode and reverts the mode back. For example: If you set your home to away mode, pressing this button sets the mode back to home. `Note:` By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                                                                                                                                                 |
| `Structure`       | `Climate` | Entity to set Flair Structure mode and Structure Set point. `Target temperature is only available when Set point controller is set to Flair app`. Please read Flair's documentation regarding [Structure mode](https://support.flair.co/hc/en-us/articles/360058466931-Mode). `Note:` By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                                                                                                                                                                                                                     |
| `System Mode`          | `Select` | Please read Flair's documentation regarding [Auto mode](https://support.flair.co/hc/en-us/articles/360042659392-System-Auto) and [Manual mode](https://support.flair.co/hc/en-us/articles/360043099291-System-Manual)                                                                                                                                                                                                                                                                           |
| `Home/Away holding until` | `Sensor` | If you have your default hold set to anything other than "Until next scheduled event", whenever setting home/away mode manually, this entity will show how much time if left until the hold ends. `Note:` This entity will only become available if there is home/away hold that is currently active. `Note:` By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                                          |
| `Away Mode`  | `Select` | Please read Flair's documentation regarding [Away Settings](https://support.flair.co/hc/en-us/articles/360041109111-Away-Settings). `Note:` By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                                                                                                                                                                                                              |
| `Away temperature maximum` | `Number` | Set your max away temperature. `Note:` This entity is only available when your set point controller is set to "Flair App". By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                                                                                                                                                                                                                      |
| `Away temperature minimum` | `Number` | Set your minimum away temperature. `Note:` This entity is only available when your set point controller is set to "Flair App". By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                                                                                                                                                                                                                  |
| `Default hold duration` | `Select` | Select your default hold duration. `Note:` By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `Home/Away mode set by` | `Select` | Available options inclue App Geolocation, Manual, or (if you have a thermostat linked to Flair) Thermostat. `Note:` By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                                                                                                                                                                                                                                     |
| `Set point controller` | `Select` | Select what is being used to set the set point for your home. Options include Flair App and Thermostat (only if you have a thermostat linked to Flair). `Note:` By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                                                                                                                                                                                         |

## Bridge

Each bridge has the following entities:

| Entity               | Entity Type | Additional Comments |
|----------------------|-------------| --- |
| `LED brightness`          | `Number`    | Brightness between 20-100. |
| `Connection status`          | `Binary Sensor`    | Used to show if the bridge is reported as being online by Flair. |
| `RSSI`               | `Sensor`    | If your bridge is connected via ethernet, this sensor will always report 0.0 |

## Puck

Each puck has the following entities:

| Entity               | Entity Type | Additional Comments |
|----------------------|-------------| --- |
| `Lock puck`          | `Switch`    | Locking a puck will prevent someone from rotating the puck to adjust the set point. |
| `Humidity`           | `Sensor`    | |
| `Light`              | `Sensor`    | |
| `Pressure` |  `Sensor`   | Room pressure reported by the puck. |
| `Temperature`        | `Sensor`    | |
| `Background color` | `Select` | Set the puck's background color to either black or white. |
| `Set point lower limit` | `Number` | |
| `Set point upper limit` | `Number` | |
| `Temperature calibration` | `Number` | |
| `Temperature scale` | `Select` | |
| `Associated gateway`            | `Sensor`    | Displays the name of the gateway (as named in the Flair app) the puck is using. If the puck is a gateway itself, this sensor will read "Self". |
| `Connection status`          | `Binary Sensor`    | Used to show if the puck is reported as being online by Flair. |
| `RSSI`               | `Sensor`    | |
| `Voltage`            | `Sensor`    | Displays the current voltage of the puck. If using batteries to power your puck, this can be used to monitor battery health. |

**Note About Pucks**

Flair statement regarding Puck Light Level sensor:

>  It is not calibrated. The sensor itself, if the nominal reference is 1, can range from 0.3 to 1.6. This also doesn't take into account the mechanical loss in the Puck. In short, this is not an accurate lux sensor.


## Vent

<p align="center">
  <img width="533" height="1000" src="https://github.com/RobertD502/home-assistant-flair/blob/main/images/flair_system_setting_smaller.png?raw=true">
</p>

In order to control vents that are in Flair Rooms that have a temperature sensor, the System setting in the Flair app needs to be set to `Manual` (see image above). If you have it set to `Auto`, you will still be able to control your vents, however, eventually Flair will override your changes. This mode can also be set using a Flair Structure's `System Mode select entity` within Home Assistant.

**Any vents in Flair Rooms that don't report temperature can be controlled regardless of current mode set.**

Each Vent has the following entities:

| Entity | Entity Type | Additional Comments |
| --- | --- | --- |
| `Vent` | `Cover` | Has a state of either `open` or `closed`. If your vent is either `50` or `100` percent open, the state will be `open`. If your vent is `0` percent open, the state will be `closed`. You can manually open the vent halfway (50 percent) by either changing the tilt position to `50` via the UI or by using the service `cover.set_cover_tilt_position` and setting `tilt position` to `50`. Note: Although you can move the slider to any value between 0-100, any tilt position other than `0` or `100` will be interpreted as `50` - this is a Flair vent limitation as it doesn't support any other position aside from 0, 50, or 100. |
| `Duct Pressure` | `Sensor` | |
| `Duct Temperature` | `Sensor` | |
| `Reported state` | `Sensor` | This entity is disabled by default. Value corresponds to the percent open of the vent as last reported by the sensor on the vent itself. Can be used in automations to determine if puck failed to open/close a vent by comparing if the state of this sensor is equal to the position of the related vent cover entity (for example checking 5 minutes after the current position of the vent cover entity changed). |
| `Associated gateway`            | `Sensor`    | Displays the name of the bridge or puck (as named in the Flair app) the vent is using as a gateway. |
| `Connection status`          | `Binary Sensor`    | Used to show if the vent is reported as being online by Flair. |
| `RSSI` | `Sensor` | |
| `Voltage` | `Sensor` | Displays the current voltage of the vent. If using batteries to power your vent, this can be used to monitor battery health. |

## Room

Each Room has the following entities:

| Entity                      | Entity Type | Additional Comments                                                                                                                                                                                                                                                               |
|-----------------------------| --- |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Activity Status`           | `Select` | Rooms can be set to Active or Inactive. `Note:` By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                                                                                           |
| `Clear hold`                | `Button` | Clears the current temperature set point change hold time and reverts back to the original set point. `Note:` By default, this entity is disabled if Flair system mode is set to manual.                                                                                                                                                                             |
| `Room`                      | `Climate` | Temperature set points can be changed on a room by room basis. Changing HVAC mode for a room propagates that change to all rooms as the HVAC mode is set at the Structure level. `Note:` By default, this entity is disabled if Flair system mode is set to manual.                                                                                                  |
| `Temperature holding until` | `Sensor` | If you have the default hold duration set to anything other than "Until next scheduled event", this entity will show you how much time is left until the manual temperature hold expires. `Note:` This entity is only available if there is a currently active hold for the room. By default, this entity is disabled if Flair system mode is set to manual. |

**Additional Notes**

Changing the temperature for a room climate entity will change the set temperature of the corresponding room. This change will remain for `until next scheduled event`, `3h`, `8h`, `24h`, or `forever`- this depends on the setting in the Flair app under Home Settings > System Settings > Default Hold Duration. This can also be changed using the "Default hold duration" entity in Home Assistant.


## IR HVAC Unit

Each IR HVAC unit has the following entities:

| Entity      | Entity Type | Additional Comments |
|-------------| --- |---------------------|
| `HVAC unit` | `Climate` | SEE NOTE BELOW      |

> To fully control your unit, the associated Flair structure needs to be in `Manual Mode`.
> 
> If your structure is set to `Auto Mode`: you will only be able to control `Fan speed` and `Swing` (if available for your unit). In addition, mini split temperature set point is controlled by rooms if a Flair structure is set to `Auto Mode`. Changing the temperature of this climate entity will result in changing the room set point when in `Auto Mode`. You also cannot change the HVAC mode as this is controlled at the Structure level when in auto mode.
> 
> If your structure is set to `Manual Mode`: Setting the HVAC mode to `Off` will turn your HVAC unit off. In order to turn the unit on, set the HVAC mode to your desired HVAC mode (Heat, Cool, Fan Only, etc).

### If your HVAC unit only has standalone buttons in the Flair app:

For these HVAC units `button` entities are created depending on what control is available (Temp +, Temp -, Fan +, Fan -, etc).
In addition, a `Last button pressed` `sensor` entity is created showing the last command sent to the HVAC unit by Flair. By default, if the Flair API doesn't return a value for the last button pressed, the sensor will have a state of `No button pressed`.
